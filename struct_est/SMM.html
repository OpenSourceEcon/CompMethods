

<!DOCTYPE html>


<html lang="en" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>Simulated Method of Moments Estimation &#8212; Computational Methods for Economists using Python</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=c5ced968eda925caa686" rel="stylesheet" />
<link href="../_static/styles/bootstrap.css?digest=c5ced968eda925caa686" rel="stylesheet" />
<link href="../_static/styles/pydata-sphinx-theme.css?digest=c5ced968eda925caa686" rel="stylesheet" />

  
  <link href="../_static/vendor/fontawesome/6.1.2/css/all.min.css?digest=c5ced968eda925caa686" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" href="../_static/styles/sphinx-book-theme.css?digest=14f4ca6b54d191a8c7657f6c759bf11a5fb86285" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/exercise.css" />
    <link rel="stylesheet" type="text/css" href="../_static/proof.css" />
    <link rel="stylesheet" type="text/css" href="../_static/custom.css" />
    <link rel="stylesheet" type="text/css" href="../_static/design-style.4045f2051d55cab465a707391d5b2007.min.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/bootstrap.js?digest=c5ced968eda925caa686" />
<link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=c5ced968eda925caa686" />
  <script src="../_static/vendor/fontawesome/6.1.2/js/all.min.js?digest=c5ced968eda925caa686"></script>

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script src="../_static/scripts/sphinx-book-theme.js?digest=5a5c038af52cf7bc1a1ec88eea08e6366ee68824"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'struct_est/SMM';</script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Glossary" href="../appendix/glossary.html" />
    <link rel="prev" title="Generalized Method of Moments Estimation" href="GMM.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a class="skip-link" href="#main-content">Skip to main content</a>
  
  <div id="pst-scroll-pixel-helper"></div>

  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>
    Back to top
  </button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>
  
    <nav class="bd-header navbar navbar-expand-lg bd-navbar">
    </nav>
  
  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">
  

<a class="navbar-brand logo" href="../index.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../_static/CompMethodsLogo.png" class="logo__image only-light" alt="Computational Methods for Economists using Python - Home"/>
    <script>document.write(`<img src="../_static/CompMethodsLogo.png" class="logo__image only-dark" alt="Computational Methods for Economists using Python - Home"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item"><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../index.html">
                    Computational Methods for Economists using Python
                </a>
            </li>
        </ul>
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Contributor Guide</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../contrib/contributing.html">Contributor Guide</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Coding in Python</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../python/intro.html">Introduction to Python</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python/StandardLibrary.html">Python Standard Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python/ExceptionsIO.html">Exception Handling and File Input/Output</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python/OOP.html">Object Oriented Programming</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python/NumPy.html">NumPy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python/Pandas.html">Pandas</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python/Matplotlib.html">Matplotlib</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python/SciPy.html">SciPy: Root finding, minimizing, interpolation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python/DocStrings.html">Docstrings and Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python/UnitTesting.html">Unit Testing</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Git and GitHub</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../git/intro.html">Git and GitHub</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Basic Causal Inference</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../caus_inf/intro.html">Basic Causal Inference</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Basic Machine Learning</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../basic_ml/intro.html">Basic Machine Learning</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Neural Nets and Deep Learning</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../deep_learn/intro.html">Neural Nets and Deep Learning</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Structural Estimation</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="intro.html">Introduction to Structural Estimation</a></li>
<li class="toctree-l1"><a class="reference internal" href="MaxLikelihood.html">Maximum Likelihood Estimation</a></li>
<li class="toctree-l1"><a class="reference internal" href="GMM.html">Generalized Method of Moments Estimation</a></li>
<li class="toctree-l1 current active"><a class="current reference internal" href="#">Simulated Method of Moments Estimation</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Appendix</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../appendix/glossary.html">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../appendix/appendix.html">Appendix</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">References</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../CompMethods_references.html">References</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><label class="sidebar-toggle primary-toggle btn btn-sm" for="__primary" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</label></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/OpenSourceEcon/CompMethods" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/OpenSourceEcon/CompMethods/issues/new?title=Issue%20on%20page%20%2Fstruct_est/SMM.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../_sources/struct_est/SMM.md" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.md</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>


<script>
document.write(`
  <button class="btn btn-sm navbar-btn theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch nav-link" data-mode="light"><i class="fa-solid fa-sun fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="dark"><i class="fa-solid fa-moon fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="auto"><i class="fa-solid fa-circle-half-stroke fa-lg"></i></span>
  </button>
`);
</script>

<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<label class="sidebar-toggle secondary-toggle btn btn-sm" for="__secondary"title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</label>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Simulated Method of Moments Estimation</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#the-smm-estimator">The SMM estimator</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#the-weighting-matrix-w">The Weighting Matrix (W)</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#the-identity-matrix-w-i">The identity matrix (W=I)</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#two-step-variance-covariance-estimator-of-w">Two-step variance-covariance estimator of W</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#iterated-variance-covariance-estimator-of-w">Iterated variance-covariance estimator of W</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#newey-west-consistent-estimator-of-omega-and-w">Newey-West consistent estimator of <span class="math notranslate nohighlight">\(\Omega\)</span> and W</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#variance-covariance-estimator-of-hat-theta">Variance-Covariance Estimator of <span class="math notranslate nohighlight">\(\hat{\theta}\)</span></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#code-examples">Code Examples</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#fitting-a-truncated-normal-to-intermediate-macroeconomics-test-scores">Fitting a truncated normal to intermediate macroeconomics test scores</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#two-moments-identity-weighting-matrix">Two moments, identity weighting matrix</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#two-moments-two-step-optimal-weighting-matrix">Two moments, two-step optimal weighting matrix</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#four-moments-identity-matrix-weighting-matrix">Four moments, identity matrix weighting matrix</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#four-moments-two-step-optimal-weighting-matrix">Four moments, two-step optimal weighting matrix</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#brock-and-mirman-1972-estimation-by-smm">Brock and Mirman (1972) estimation by SMM</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#secsmm-ident">Identification</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#indirect-inference">Indirect inference</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#restatement-of-the-general-smm-estimation-problem">Restatement of the general SMM estimation problem</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#indirect-inference-estimation-problem">Indirect inference estimation problem</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#hypothesis-testing-with-indirect-inference">Hypothesis testing with indirect inference</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#exercises">Exercises</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#footnotes">Footnotes</a></li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article" role="main">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="simulated-method-of-moments-estimation">
<span id="chap-smm"></span><h1>Simulated Method of Moments Estimation<a class="headerlink" href="#simulated-method-of-moments-estimation" title="Permalink to this heading">#</a></h1>
<p>This chapter describes the simulated method of moments (SMM) estimation method. All data and images from this chapter can be found in the data directory (<a class="reference external" href="https://github.com/OpenSourceEcon/CompMethods/tree/main/data/smm/">./data/smm/</a>) and images directory (<a class="reference external" href="https://github.com/OpenSourceEcon/CompMethods/tree/main/images/smm/">./images/smm/</a>) for the GitHub repository for this online book.</p>
<section id="the-smm-estimator">
<span id="secsmmestimator"></span><h2>The SMM estimator<a class="headerlink" href="#the-smm-estimator" title="Permalink to this heading">#</a></h2>
<p>Simulated method of moments (SMM) is analogous to the generalized method of moments (GMM) estimator. SMM could really be thought of as a particular type of GMM estimator. The SMM estimator chooses a vector of model parameters <span class="math notranslate nohighlight">\(\theta\)</span> to make simulated model moments match data moments. Seminal papers developing SMM are <span id="id1">[<a class="reference internal" href="../CompMethods_references.html#id37" title="Daniel McFadden. A method of simulated moments for estimation of discrete response models without numerical integration. Econometrica, 57(5):995-1026, September 1989.">McFadden, 1989</a>]</span>, <span id="id2">[<a class="reference internal" href="../CompMethods_references.html#id36" title="Bong-Soo Lee and Beth Fisher Ingram. Simulation estimation of time series models. Journal of Econometrics, 47(2-3):197-205, February 1991.">Lee and Ingram, 1991</a>]</span>, and <span id="id3">[<a class="reference internal" href="../CompMethods_references.html#id21" title="Darrell Duffie and Kenneth J. Singleton. Simulated moment estimation of markov models of asset prices. Econometrica, 61(4):929-952, July 1993.">Duffie and Singleton, 1993</a>]</span>. Good textbook treatments of SMM are found in <span id="id4">[<a class="reference internal" href="../CompMethods_references.html#id2" title="Jérôme Adda and Russell Cooper. Dynamic Economics: Quantitative Methods and Applications. MIT Press, 2003.">Adda and Cooper, 2003</a>]</span>, (pp. 87-100) and <span id="id5">[<a class="reference internal" href="../CompMethods_references.html#id20" title="Russell Davidson and James G. MacKinnon. Econometric Theory and Methods. Oxford University Press, 2004.">Davidson and MacKinnon, 2004</a>]</span>, (pp. 383-394).</p>
<p>Let the data be represented, in general, by <span class="math notranslate nohighlight">\(x\)</span>. This could have many variables, and it could be cross-sectional or time series. We define the estimation problem as one in which we want to model the data <span class="math notranslate nohighlight">\(x\)</span> using some parameterized model <span class="math notranslate nohighlight">\(g(x|\theta)\)</span> in which <span class="math notranslate nohighlight">\(\theta\)</span> is a <span class="math notranslate nohighlight">\(K\times 1\)</span> vector of parameters.</p>
<div class="math notranslate nohighlight" id="equation-eqsmm-thetavec">
<span class="eqno">(7)<a class="headerlink" href="#equation-eqsmm-thetavec" title="Permalink to this equation">#</a></span>\[    \theta \equiv \left[\theta_1, \theta_2, ...\theta_K\right]^T\]</div>
<p>In the <a class="reference internal" href="MaxLikelihood.html#chap-maxlikeli"><span class="std std-ref">Maximum Likelihood Estimation</span></a> chapter, we used data <span class="math notranslate nohighlight">\(x\)</span> and model parameters <span class="math notranslate nohighlight">\(\theta\)</span> to maximize the likelihood of drawing that data <span class="math notranslate nohighlight">\(x\)</span> from the model given parameters <span class="math notranslate nohighlight">\(\theta\)</span>,</p>
<div class="math notranslate nohighlight" id="equation-eqsmm-mlestimator">
<span class="eqno">(8)<a class="headerlink" href="#equation-eqsmm-mlestimator" title="Permalink to this equation">#</a></span>\[    \hat{\theta}_{ML} = \theta:\quad \max_{\theta}\ln\mathcal{L} = \sum_{i=1}^N\ln\Bigl(f(x_i|\theta)\Bigr)\]</div>
<p>where <span class="math notranslate nohighlight">\(f(x_i|\theta)\)</span> is the likelihood of seeing observation <span class="math notranslate nohighlight">\(x_i\)</span> in the data <span class="math notranslate nohighlight">\(x\)</span> given vector of parameters <span class="math notranslate nohighlight">\(\theta\)</span>.</p>
<p>In the <a class="reference internal" href="GMM.html#chap-gmm"><span class="std std-ref">Generalized Method of Moments Estimation</span></a> chapter, we used data <span class="math notranslate nohighlight">\(x\)</span> and the <span class="math notranslate nohighlight">\(K\times 1\)</span> vector of model parameters <span class="math notranslate nohighlight">\(\theta\)</span> to minimize the distance between the vector of <span class="math notranslate nohighlight">\(R\geq K\)</span> model moments <span class="math notranslate nohighlight">\(m(x|\theta)\)</span> and data moments <span class="math notranslate nohighlight">\(m(x)\)</span>,</p>
<div class="math notranslate nohighlight" id="equation-eqsmm-gmmestimator">
<span class="eqno">(9)<a class="headerlink" href="#equation-eqsmm-gmmestimator" title="Permalink to this equation">#</a></span>\[    \hat{\theta}_{GMM} = \theta:\quad \min_{\theta}||m(x|\theta) - m(x)||\]</div>
<p>where,</p>
<div class="math notranslate nohighlight" id="equation-eqsmm-modmomfuncvecgen">
<span class="eqno">(10)<a class="headerlink" href="#equation-eqsmm-modmomfuncvecgen" title="Permalink to this equation">#</a></span>\[    m(x|\theta) \equiv \left[m_1(x|\theta), m_2(x|\theta),...m_R(x|\theta)\right]^T\]</div>
<p>and,</p>
<div class="math notranslate nohighlight" id="equation-eqsmm-datamomfuncvecgen">
<span class="eqno">(11)<a class="headerlink" href="#equation-eqsmm-datamomfuncvecgen" title="Permalink to this equation">#</a></span>\[    m(x)\equiv \left[m_1(x), m_2(x), ...m_R(x)\right]^T\]</div>
<p>The following difficulties can arise with GMM making it not possible or very difficult.</p>
<ul class="simple">
<li><p>The model moment function <span class="math notranslate nohighlight">\(m(x|\theta)\)</span> is not known analytically.</p></li>
<li><p>The data moments you are trying to match come from another model (indirect inference, see <span id="id6">[<a class="reference internal" href="../CompMethods_references.html#id44" title="Anthony A. Jr. Smith. Indirect inference. In Matias Vernengo, Esteban Perez Caldentey, and Barkley J. Rosser Jr., editors, New Palgrave Dictionary of Economics. Palgrave MacMillan, 2020. URL: http://www.econ.yale.edu/smith/palgrave7.pdf.">Smith, 2020</a>]</span>).</p></li>
<li><p>The model moments <span class="math notranslate nohighlight">\(m(x|\theta)\)</span> are derived from <em>latent variables</em> that are not observed by the modeler. You only have moments, not the underlying data. See <span id="id7">[<a class="reference internal" href="../CompMethods_references.html#id35" title="G. Laroque and B. Salanié. Simulation based estimation models with lagged latent variables. Journal of Applied Econometrics, 8(Supplement):119-133, December 1993.">Laroque and Salanié, 1993</a>]</span>.</p></li>
<li><p>The model moments <span class="math notranslate nohighlight">\(m(x|\theta)\)</span> are derived from <em>censored variables</em> that are only partially observed by the modeler.</p></li>
<li><p>The model moments <span class="math notranslate nohighlight">\(m(x|\theta)\)</span> are just difficult to derive analytically. Examples include moments that include multiple integrals over nonlinear functions as in <span id="id8">[<a class="reference internal" href="../CompMethods_references.html#id37" title="Daniel McFadden. A method of simulated moments for estimation of discrete response models without numerical integration. Econometrica, 57(5):995-1026, September 1989.">McFadden, 1989</a>]</span>.</p></li>
</ul>
<p>SMM estimation is simply to simulate the model data <span class="math notranslate nohighlight">\(S\)</span> times, and use the average values of the moments from the simulated data as the estimator for the model moments. Let <span class="math notranslate nohighlight">\(\tilde{x}\equiv\{\tilde{x}_1,\tilde{x}_2,...\tilde{x}_s,...\tilde{x}_S\}\)</span> be the <span class="math notranslate nohighlight">\(S\)</span> simulations of the model data. And let the maximization problem in <a class="reference internal" href="#equation-eqsmm-smmestimator">(14)</a> be characterized by <span class="math notranslate nohighlight">\(R\)</span> average moments across simulations, where <span class="math notranslate nohighlight">\(\hat{m}_r\)</span> is the average value of the <span class="math notranslate nohighlight">\(r\)</span>th moment across the <span class="math notranslate nohighlight">\(S\)</span> simulations where,</p>
<div class="math notranslate nohighlight" id="equation-eqsmm-avgsimmoms-r">
<span class="eqno">(12)<a class="headerlink" href="#equation-eqsmm-avgsimmoms-r" title="Permalink to this equation">#</a></span>\[    \hat{m}_r\left(\tilde{x}|\theta\right) = \frac{1}{S}\sum_{s=1}^S m_r\left(\tilde{x}_s|\theta\right)\]</div>
<p>and</p>
<div class="math notranslate nohighlight" id="equation-eqsmm-avgsimmoms-vec">
<span class="eqno">(13)<a class="headerlink" href="#equation-eqsmm-avgsimmoms-vec" title="Permalink to this equation">#</a></span>\[    \hat{m}\left(\tilde{x}|\theta\right) = \left[m_1\left(\tilde{x}|\theta\right), m_2\left(\tilde{x}|\theta\right),...m_R\left(\tilde{x}|\theta\right)\right]^T\]</div>
<p>Once we have an estimate of the vector of <span class="math notranslate nohighlight">\(R\)</span> average model moments <span class="math notranslate nohighlight">\(\hat{m}\left(\tilde{x}|\theta\right)\)</span> from our <span class="math notranslate nohighlight">\(S\)</span> simulations, SMM estimation is very similar to our presentation of GMM in <a class="reference internal" href="GMM.html#chap-gmm"><span class="std std-ref">Generalized Method of Moments Estimation</span></a>. The SMM approach of estimating the <span class="math notranslate nohighlight">\(K\times 1\)</span> parameter vector <span class="math notranslate nohighlight">\(\hat{\theta}_{SMM}\)</span> is to choose vector <span class="math notranslate nohighlight">\(\theta\)</span> to minimize some distance measure of the <span class="math notranslate nohighlight">\(R\)</span> data moments <span class="math notranslate nohighlight">\(m(x)\)</span> from the <span class="math notranslate nohighlight">\(R\)</span> simulated average model moments <span class="math notranslate nohighlight">\(\hat{m}(\tilde{x}|\theta)\)</span>.</p>
<div class="math notranslate nohighlight" id="equation-eqsmm-smmestimator">
<span class="eqno">(14)<a class="headerlink" href="#equation-eqsmm-smmestimator" title="Permalink to this equation">#</a></span>\[    \hat{\theta}_{SMM}=\theta:\quad \min_{\theta}\: ||\hat{m}(\tilde{x}|\theta)-m(x)||\]</div>
<p>The distance measure <span class="math notranslate nohighlight">\(||\hat{m}(\tilde{x}|\theta)-m(x)||\)</span> can be any kind of norm. But it is important to recognize that your estimates <span class="math notranslate nohighlight">\(\hat{\theta}_{SMM}\)</span> will be dependent on what distance measure (norm) you choose. The most widely studied and used distance metric in GMM and SMM estimation is the <span class="math notranslate nohighlight">\(L^2\)</span> norm or the sum of squared errors in moments.</p>
<p>Define the moment error vector <span class="math notranslate nohighlight">\(e(\tilde{x},x|\theta)\)</span> as the <span class="math notranslate nohighlight">\(R\times 1\)</span> vector of average moment error functions <span class="math notranslate nohighlight">\(e_r(\tilde{x},x|\theta)\)</span> of the <span class="math notranslate nohighlight">\(r\)</span>th average moment error.</p>
<div class="math notranslate nohighlight" id="equation-eqsmm-momerror-vec">
<span class="eqno">(15)<a class="headerlink" href="#equation-eqsmm-momerror-vec" title="Permalink to this equation">#</a></span>\[    e_(\tilde{x},x|\theta) \equiv \left[e_1(\tilde{x},x|\theta),e_2(\tilde{x},x|\theta),...e_R(\tilde{x},x|\theta)\right]^T\]</div>
<p>We can define the <span class="math notranslate nohighlight">\(r\)</span>th average moment error as the percent difference in the average simulated <span class="math notranslate nohighlight">\(r\)</span>th moment value <span class="math notranslate nohighlight">\(\hat{m}_r(\tilde{x}|\theta)\)</span> from the <span class="math notranslate nohighlight">\(r\)</span>th data moment <span class="math notranslate nohighlight">\(m_r(x)\)</span>.</p>
<div class="math notranslate nohighlight" id="equation-eqsmm-momerror-r">
<span class="eqno">(16)<a class="headerlink" href="#equation-eqsmm-momerror-r" title="Permalink to this equation">#</a></span>\[    e_r(\tilde{x},x|\theta) \equiv \frac{\hat{m}_r(\tilde{x}|\theta)-m_r(x)}{m_r(x)} \quad\text{or}\quad \hat{m}_r(\tilde{x}|\theta)-m_r(x)\]</div>
<p>It is important that the error function <span class="math notranslate nohighlight">\(e_r(\tilde{x},x|\theta)\)</span> be a percent deviation of the moments, although this will not work if the data moments are 0 or can be either positive or negative. This percent change transformation puts all the moments in the same units, which helps make sure that no moments receive unintended weighting simply due to its units. This ensures that the problem is scaled properly and will suffer from as little as possible ill conditioning.</p>
<p>In this case, the SMM estimator is the following,</p>
<div class="math notranslate nohighlight" id="equation-eqsmm-smmestgen">
<span class="eqno">(17)<a class="headerlink" href="#equation-eqsmm-smmestgen" title="Permalink to this equation">#</a></span>\[    \hat{\theta}_{SMM}=\theta:\quad \min_{\theta}\:e(\tilde{x},x|\theta)^T \, W \, e(\tilde{x},x|\theta)\]</div>
<p>where <span class="math notranslate nohighlight">\(W\)</span> is a <span class="math notranslate nohighlight">\(R\times R\)</span> weighting matrix in the criterion function. For now, think of this weighting matrix as the identity matrix. But we will show in Section <a class="reference internal" href="#secsmm-weightmatw"><span class="std std-ref">The Weighting Matrix (W)</span></a> a more optimal weighting matrix. We call the quadratic form expression <span class="math notranslate nohighlight">\(e(\tilde{x},x|\theta)^T \, W \, e(\tilde{x},x|\theta)\)</span> the <em>criterion function</em> because it is a strictly positive scalar that is the object of the minimization in the SMM problem statement. The <span class="math notranslate nohighlight">\(R\times R\)</span> weighting matrix <span class="math notranslate nohighlight">\(W\)</span> in the criterion function allows the econometrician to control how each moment is weighted in the minimization problem. For example, an <span class="math notranslate nohighlight">\(R\times R\)</span> identity matrix for <span class="math notranslate nohighlight">\(W\)</span> would give each moment equal weighting, and the criterion function would be a simply sum of squared percent deviations (errors). Other weighting strategies can be dictated by the nature of the problem or model.</p>
<p>One last item to emphasize with SMM, which we will highlight in the examples in this chapter, is that the errors that are drawn for the <span class="math notranslate nohighlight">\(S\)</span> simulations of the model must be drawn only once so that the minimization problem for estimating <span class="math notranslate nohighlight">\(\hat{\theta}_{SMM}\)</span> does not have the underlying sampling changing for each guess of a value of <span class="math notranslate nohighlight">\(\theta\)</span>. Put more simply, you want the random draws for all the simulations to be held constant so that the only thing changing in the minimization problem is the value of the vector of parameters <span class="math notranslate nohighlight">\(\theta\)</span>.</p>
</section>
<section id="the-weighting-matrix-w">
<span id="secsmm-weightmatw"></span><h2>The Weighting Matrix (W)<a class="headerlink" href="#the-weighting-matrix-w" title="Permalink to this heading">#</a></h2>
<p>In the SMM criterion function in the problem statement above, some weighting matrices <span class="math notranslate nohighlight">\(W\)</span> produce precise estimates while others produce poor estimates with large variances. We want to choose the optimal weighting matrix <span class="math notranslate nohighlight">\(W\)</span> with the smallest possible asymptotic variance. This is an efficient or optimal SMM estimator. The optimal weighting matrix is the inverse variance covariance matrix of the moments at the optimal moments,</p>
<div class="math notranslate nohighlight" id="equation-eqsmm-estw-opt">
<span class="eqno">(18)<a class="headerlink" href="#equation-eqsmm-estw-opt" title="Permalink to this equation">#</a></span>\[    W^{opt} \equiv \Omega^{-1}(\tilde{x},x|\hat{\theta}_{SMM})\]</div>
<p>where <span class="math notranslate nohighlight">\(\Omega(\tilde{x},x|\theta)\)</span> is the variance covariance matrix of the moment condition errors <span class="math notranslate nohighlight">\(e(\tilde{x},x|\theta)\)</span>. The intuition for using the inverse variance covariance matrix <span class="math notranslate nohighlight">\(\Omega^{-1}\)</span> as the optimal weighting matrix is the following. You want to downweight moments that have a high variance, and you want to weight more heavily the moments that are generated more precisely.</p>
<p>Notice that this definition of the optimal weighting matrix is circular. <span class="math notranslate nohighlight">\(W^{opt}\)</span> is a function of the SMM estimates <span class="math notranslate nohighlight">\(\hat{\theta}_{SMM}\)</span>, but the optimal weighting matrix is used in the estimation of <span class="math notranslate nohighlight">\(\hat{\theta}_{SMM}\)</span>. This means that one has to use some kind of iterative fixed point method to find the true optimal weighting matrix <span class="math notranslate nohighlight">\(W^{opt}\)</span>. Below are some examples of weighting matrices to use.</p>
<section id="the-identity-matrix-w-i">
<span id="secsmm-w-i"></span><h3>The identity matrix (W=I)<a class="headerlink" href="#the-identity-matrix-w-i" title="Permalink to this heading">#</a></h3>
<p>Many times, you can get away with just using the identity matrix as your weighting matrix <span class="math notranslate nohighlight">\(W = I\)</span>. This changes the criterion function to a simple sum of squared error functions such that each moment has the same weight.</p>
<div class="math notranslate nohighlight" id="equation-eqsmm-estw-i">
<span class="eqno">(19)<a class="headerlink" href="#equation-eqsmm-estw-i" title="Permalink to this equation">#</a></span>\[    \hat{\theta}_{SMM}=\theta:\quad \min_{\theta}\:e(\tilde{x},x|\theta)^T \, e(\tilde{x},x|\theta)\]</div>
<p>If the problem is well conditioned and well identified, then your SMM estimates <span class="math notranslate nohighlight">\(\hat{\theta}_{SMM}\)</span> will not be greatly affected by this simplest of weighting matrices.</p>
</section>
<section id="two-step-variance-covariance-estimator-of-w">
<span id="secsmm-w-2step"></span><h3>Two-step variance-covariance estimator of W<a class="headerlink" href="#two-step-variance-covariance-estimator-of-w" title="Permalink to this heading">#</a></h3>
<p>The most common method of estimating the optimal weighting matrix for SMM estimates is the two-step variance covariance estimator. The name “two-step” refers to the two steps used to get the weighting matrix.</p>
<p>The first step is to estimate the SMM parameter vector <span class="math notranslate nohighlight">\(\hat{\theta}_{1,SMM}\)</span> using the simple identity matrix as the weighting matrix <span class="math notranslate nohighlight">\(W = I\)</span>.</p>
<div class="math notranslate nohighlight" id="equation-eqsmm-theta-2step-1">
<span class="eqno">(20)<a class="headerlink" href="#equation-eqsmm-theta-2step-1" title="Permalink to this equation">#</a></span>\[    \hat{\theta}_{1,SMM}=\theta:\quad \min_{\theta}\:e(\tilde{x},x|\theta)^T \, I \, e(\tilde{x},x|\theta)\]</div>
<p>Because we are simulating data, we can generate an estimator for the variance covariance matrix of the moment error vector <span class="math notranslate nohighlight">\(\hat{\Omega}\)</span> using just the simulated data moments and the data moments. This <span class="math notranslate nohighlight">\(E(\tilde{x},x|\theta)\)</span> matrix represents the contribution of the <span class="math notranslate nohighlight">\(s\)</span>th simulated moment to the <span class="math notranslate nohighlight">\(r\)</span>th moment error. Define <span class="math notranslate nohighlight">\(E(\tilde{x},x|\theta)\)</span> as the <span class="math notranslate nohighlight">\(R\times S\)</span> matrix of moment error functions from each simulation,</p>
<div class="math notranslate nohighlight" id="equation-eqsmm-estw-errmat-lev-1">
<span class="eqno">(21)<a class="headerlink" href="#equation-eqsmm-estw-errmat-lev-1" title="Permalink to this equation">#</a></span>\[\begin{split}    E(\tilde{x},x|\theta) =
      \begin{bmatrix}
        m_1(\tilde{x}_1|\theta) - m_1(x) &amp; m_1(\tilde{x}_2|\theta) - m_1(x) &amp; ... &amp; m_1(\tilde{x}_S|\theta) - m_1(x) \\
        m_2(\tilde{x}_1|\theta) - m_2(x) &amp; m_2(\tilde{x}_2|\theta) - m_2(x) &amp; ... &amp; m_2(\tilde{x}_S|\theta) - m_2(x) \\
        \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
        m_R(\tilde{x}_1|\theta) - m_R(x) &amp; m_R(\tilde{x}_2|\theta) - m_R(x) &amp; ... &amp; m_R(\tilde{x}_S|\theta) - m_R(x) \\
      \end{bmatrix}\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(m_r(x)\)</span> is the <span class="math notranslate nohighlight">\(r\)</span>th data moment which is constant across each row, and <span class="math notranslate nohighlight">\(m_r(\tilde{x}_s|\theta)\)</span> is the <span class="math notranslate nohighlight">\(r\)</span>th model moment from the <span class="math notranslate nohighlight">\(s\)</span>th simulation which are changing across each row. When the errors are percent deviations, the <span class="math notranslate nohighlight">\(E(\tilde{x},x|\theta)\)</span> matrix is the following,</p>
<div class="math notranslate nohighlight" id="equation-eqsmm-estw-errmat-pct-1">
<span class="eqno">(22)<a class="headerlink" href="#equation-eqsmm-estw-errmat-pct-1" title="Permalink to this equation">#</a></span>\[\begin{split}    E(\tilde{x},x|\theta) =
      \begin{bmatrix}
        \frac{m_1(\tilde{x}_1|\theta) - m_1(x)}{m_1(x)} &amp; \frac{m_1(\tilde{x}_2|\theta) - m_1(x)}{m_1(x)} &amp; ... &amp; \frac{m_1(\tilde{x}_S|\theta) - m_1(x)}{m_1(x)} \\
        \frac{m_2(\tilde{x}_1|\theta) - m_2(x)}{m_2(x)} &amp; \frac{m_2(\tilde{x}_2|\theta) - m_2(x)}{m_2(x)} &amp; ... &amp; \frac{m_2(\tilde{x}_S|\theta) - m_2(x)}{m_2(x)} \\
        \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
        \frac{m_R(\tilde{x}_1|\theta) - m_R(x)}{m_R(x)} &amp; \frac{m_R(\tilde{x}_2|\theta) - m_R(x)}{m_R(x)} &amp; ... &amp; \frac{m_R(\tilde{x}_S|\theta) - m_R(x)}{m_R(x)} \\
      \end{bmatrix}\end{split}\]</div>
<p>where the denominator of the percentage deviation or baseline is the model moment that does not change. We use the <span class="math notranslate nohighlight">\(E(\tilde{x},x|\theta)\)</span> data matrix and the Step 1 SMM estimate <span class="math notranslate nohighlight">\(e(x|\hat{\theta}_{1,SMM})\)</span> to get a new estimate of the variance covariance matrix.</p>
<div class="math notranslate nohighlight" id="equation-eqsmm-2stepvarcov">
<span class="eqno">(23)<a class="headerlink" href="#equation-eqsmm-2stepvarcov" title="Permalink to this equation">#</a></span>\[    \hat{\Omega}_2 = \frac{1}{S}E(\tilde{x},x|\hat{\theta}_{1,SMM})\,E(\tilde{x},x|\hat{\theta}_{1,SMM})^T\]</div>
<p>This is simply saying that the <span class="math notranslate nohighlight">\((r,s)\)</span>-element of the estimator of the variance-covariance matrix of the moment vector is the following.</p>
<div class="math notranslate nohighlight" id="equation-eqsmm-2stepvarcov-rs">
<span class="eqno">(24)<a class="headerlink" href="#equation-eqsmm-2stepvarcov-rs" title="Permalink to this equation">#</a></span>\[    \hat{\Omega}_{r,s} = \frac{1}{S}\sum_{i=1}^S\Bigl[m_r(\tilde{x}_i|\theta) - m_{r}(x)\Bigr]\Bigl[ m_s(\tilde{x}_i|\theta) - m_s(x)\Bigr]\]</div>
<p>The optimal weighting matrix is the inverse of the two-step variance covariance matrix.</p>
<div class="math notranslate nohighlight" id="equation-eqsmm-estw-2step">
<span class="eqno">(25)<a class="headerlink" href="#equation-eqsmm-estw-2step" title="Permalink to this equation">#</a></span>\[    \hat{W}^{two-step} \equiv \hat{\Omega}_2^{-1}\]</div>
<p>Lastly, re-estimate the SMM estimator using the optimal two-step weighting matrix <span class="math notranslate nohighlight">\(\hat{W}^{2step}\)</span>.</p>
<div class="math notranslate nohighlight" id="equation-eqsmm-theta-2step-2">
<span class="eqno">(26)<a class="headerlink" href="#equation-eqsmm-theta-2step-2" title="Permalink to this equation">#</a></span>\[    \hat{\theta}_{2,SMM}=\theta:\quad \min_{\theta}\:e(\tilde{x},x|\theta)^T \, \hat{W}^{two-step} \, e(\tilde{x},x|\theta)\]</div>
<p><span class="math notranslate nohighlight">\(\hat{\theta}_{2, SMM}\)</span> is called the two-step SMM estimator.</p>
</section>
<section id="iterated-variance-covariance-estimator-of-w">
<span id="secsmm-w-iter"></span><h3>Iterated variance-covariance estimator of W<a class="headerlink" href="#iterated-variance-covariance-estimator-of-w" title="Permalink to this heading">#</a></h3>
<p>The truly optimal weighting matrix <span class="math notranslate nohighlight">\(W^{opt}\)</span> is the iterated variance-covariance estimator of <span class="math notranslate nohighlight">\(W\)</span>. This procedure is to just repeat the process described in the two-step SMM estimator until the estimated weighting matrix no longer changes between iterations. Let <span class="math notranslate nohighlight">\(i\)</span> index the <span class="math notranslate nohighlight">\(i\)</span>th iterated SMM estimator,</p>
<div class="math notranslate nohighlight" id="equation-eqsmm-theta-2step-i">
<span class="eqno">(27)<a class="headerlink" href="#equation-eqsmm-theta-2step-i" title="Permalink to this equation">#</a></span>\[    \hat{\theta}_{i, SMM}=\theta:\quad \min_{\theta}\:e(\tilde{x},x|\theta)^T \, \hat{W}_{i} \, e(\tilde{x},x|\theta)\]</div>
<p>and the <span class="math notranslate nohighlight">\((i+1)\)</span>th estimate of the optimal weighting matrix is defined as the following.</p>
<div class="math notranslate nohighlight" id="equation-eqsmm-estw-istep">
<span class="eqno">(28)<a class="headerlink" href="#equation-eqsmm-estw-istep" title="Permalink to this equation">#</a></span>\[    \hat{W}_{i+1} \equiv \hat{\Omega}_{i+1}^{-1}\quad\text{where}\quad \hat{\Omega}_{i+1} = \frac{1}{S}E(\tilde{x},x|\hat{\theta}_{i,SMM})\,E(\tilde{x},x|\hat{\theta}_{i,SMM})^T\]</div>
<p>The iterated SMM estimator is the <span class="math notranslate nohighlight">\(\hat{\theta}_{i,SMM}\)</span> such that <span class="math notranslate nohighlight">\(\hat{W}_{i+1}\)</span> is very close to <span class="math notranslate nohighlight">\(\hat{W}_{i}\)</span> for some distance metric (norm).</p>
<div class="math notranslate nohighlight" id="equation-eqsmm-theta-it">
<span class="eqno">(29)<a class="headerlink" href="#equation-eqsmm-theta-it" title="Permalink to this equation">#</a></span>\[    \hat{\theta}_{it,SMM} = \hat{\theta}_{i,SMM}: \quad || \hat{W}_{i+1} - \hat{W}_{i} || &lt; \varepsilon\]</div>
</section>
<section id="newey-west-consistent-estimator-of-omega-and-w">
<span id="secsmm-w-nw"></span><h3>Newey-West consistent estimator of <span class="math notranslate nohighlight">\(\Omega\)</span> and W<a class="headerlink" href="#newey-west-consistent-estimator-of-omega-and-w" title="Permalink to this heading">#</a></h3>
<p>The Newey-West estimator of the optimal weighting matrix and variance covariance matrix is consistent in the presence of heteroskedasticity and autocorrelation in the data (See <span id="id9">[<a class="reference internal" href="../CompMethods_references.html#id39" title="Whitney K. Newey and Kenneth D. West. A simple, positive, semi-definite, heteroskedasticy and autocorrelation consistent covariance matrix. Econometrica, 55(3):703-708, May 1987.">Newey and West, 1987</a>]</span>). <span id="id10">[<a class="reference internal" href="../CompMethods_references.html#id2" title="Jérôme Adda and Russell Cooper. Dynamic Economics: Quantitative Methods and Applications. MIT Press, 2003.">Adda and Cooper, 2003</a>]</span> (p. 82) have a nice exposition of how to compute the Newey-West weighting matrix <span class="math notranslate nohighlight">\(\hat{W}_{nw}\)</span>. The asymptotic representation of the optimal weighting matrix <span class="math notranslate nohighlight">\(\hat{W}^{opt}\)</span> is the following:</p>
<div class="math notranslate nohighlight" id="equation-eqsmm-estw-whatopt">
<span class="eqno">(30)<a class="headerlink" href="#equation-eqsmm-estw-whatopt" title="Permalink to this equation">#</a></span>\[    \hat{W}^{opt} = \lim_{S\rightarrow\infty}\frac{1}{S}\sum_{i=1}^S \sum_{l=-\infty}^\infty E(\tilde{x}_i,x|\theta)E(\tilde{x}_{i-l},x|\theta)^T\]</div>
<p>The Newey-West consistend estimator of <span class="math notranslate nohighlight">\(\hat{W}^{opt}\)</span> is:</p>
<div class="math notranslate nohighlight" id="equation-eqsmm-estw-nw">
<span class="eqno">(31)<a class="headerlink" href="#equation-eqsmm-estw-nw" title="Permalink to this equation">#</a></span>\[    \hat{W}_{nw} = \Gamma_{0,S} + \sum_{v=1}^q \left(1 - \left[\frac{v}{q+1}\right]\right)\left(\Gamma_{v,S} + \Gamma^T_{v,S}\right)\]</div>
<p>where</p>
<div class="math notranslate nohighlight" id="equation-eqsmm-estw-nwgamma">
<span class="eqno">(32)<a class="headerlink" href="#equation-eqsmm-estw-nwgamma" title="Permalink to this equation">#</a></span>\[    \Gamma_{v,S} = \frac{1}{S}\sum_{i=v+1}^S E(\tilde{x}_i,x|\theta)E(\tilde{x}_{i-v},x|\theta)^T\]</div>
<p>Of course, for autocorrelation, the subscript <span class="math notranslate nohighlight">\(i\)</span> can be changed to <span class="math notranslate nohighlight">\(t\)</span>.</p>
</section>
</section>
<section id="variance-covariance-estimator-of-hat-theta">
<span id="secsmm-varcovtheta"></span><h2>Variance-Covariance Estimator of <span class="math notranslate nohighlight">\(\hat{\theta}\)</span><a class="headerlink" href="#variance-covariance-estimator-of-hat-theta" title="Permalink to this heading">#</a></h2>
<p>Let the parameter vector <span class="math notranslate nohighlight">\(\theta\)</span> have length <span class="math notranslate nohighlight">\(K\)</span> such that <span class="math notranslate nohighlight">\(K\)</span> parameters are being estimated. The estimated <span class="math notranslate nohighlight">\(K\times K\)</span> variance-covariance matrix <span class="math notranslate nohighlight">\(\hat{\Sigma}\)</span> of the estimated parameter vector <span class="math notranslate nohighlight">\(\hat{\theta}_{SMM}\)</span> is different from the <span class="math notranslate nohighlight">\(R\times R\)</span> variance-covariance matrix <span class="math notranslate nohighlight">\(\hat{\Omega}\)</span> of the <span class="math notranslate nohighlight">\(R\times 1\)</span> moment vector <span class="math notranslate nohighlight">\(e(\tilde{x},x|\theta)\)</span> from the previous section.</p>
<p>Recall that each element of <span class="math notranslate nohighlight">\(e(\tilde{x},x|\theta)\)</span> is an average moment error across all simulations. <span class="math notranslate nohighlight">\(\hat{\Omega}\)</span> from the previous section is the <span class="math notranslate nohighlight">\(R\times R\)</span> variance-covariance matrix of the <span class="math notranslate nohighlight">\(R\)</span> moment errors used to identify the <span class="math notranslate nohighlight">\(K\)</span> parameters <span class="math notranslate nohighlight">\(\theta\)</span> to be estimated. The estimated variance-covariance matrix <span class="math notranslate nohighlight">\(\hat{\Sigma}\)</span> of the estimated parameter vector is a <span class="math notranslate nohighlight">\(K\times K\)</span> matrix. We say the model is <em>exactly identified</em> if <span class="math notranslate nohighlight">\(K = R\)</span> (number of parameters <span class="math notranslate nohighlight">\(K\)</span> equals number of moments <span class="math notranslate nohighlight">\(R\)</span>). We say the model is <em>overidentified</em> if <span class="math notranslate nohighlight">\(K&lt;R\)</span>. We say the model is <em>not identified</em> or <em>underidentified</em> if <span class="math notranslate nohighlight">\(K&gt;R\)</span>.</p>
<p>Similar to the inverse Hessian estimator of the variance-covariance matrix of the maximum likelihood estimator from the <a class="reference internal" href="MaxLikelihood.html#chap-maxlikeli"><span class="std std-ref">Maximum Likelihood Estimation</span></a> chapter, the SMM variance-covariance matrix is related to the derivative of the criterion function with respect to each parameter. The intuition is that if the second derivative of the criterion function with respect to the parameters is large, there is a lot of curvature around the criterion minimizing estimate. In other words, the parameters of the model are precisely estimated. The inverse of the Hessian matrix will be small.</p>
<p>Define <span class="math notranslate nohighlight">\(R\times K\)</span> matrix <span class="math notranslate nohighlight">\(d(\tilde{x},x|\theta)\)</span> as the Jacobian matrix of derivatives of the <span class="math notranslate nohighlight">\(R\times 1\)</span> error vector <span class="math notranslate nohighlight">\(e(\tilde{x},x|\theta)\)</span> from <a class="reference internal" href="#equation-eqsmm-momerror-vec">(15)</a>.</p>
<div class="math notranslate nohighlight" id="equation-eqsmm-errvec-deriv">
<span class="eqno">(33)<a class="headerlink" href="#equation-eqsmm-errvec-deriv" title="Permalink to this equation">#</a></span>\[\begin{split}    \begin{equation}
      d(\tilde{x},x|\theta) \equiv
        \begin{bmatrix}
          \frac{\partial e_1(\tilde{x},x|\theta)}{\partial \theta_1} &amp; \frac{\partial e_1(\tilde{x},x|\theta)}{\partial \theta_2} &amp; ... &amp; \frac{\partial e_1(\tilde{x},x|\theta)}{\partial \theta_K} \\
          \frac{\partial e_2(\tilde{x},x|\theta)}{\partial \theta_1} &amp; \frac{\partial e_2(\tilde{x},x|\theta)}{\partial \theta_2} &amp; ... &amp; \frac{\partial e_2(\tilde{x},x|\theta)}{\partial \theta_K} \\
          \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
          \frac{\partial e_R(\tilde{x},x|\theta)}{\partial \theta_1} &amp; \frac{\partial e_R(\tilde{x},x|\theta)}{\partial \theta_2} &amp; ... &amp; \frac{\partial e_R(x|\theta)}{\partial \theta_K}
        \end{bmatrix}
    \end{equation}\end{split}\]</div>
<p>The SMM estimates of the parameter vector <span class="math notranslate nohighlight">\(\hat{\theta}_{SMM}\)</span> are assymptotically normal. If <span class="math notranslate nohighlight">\(\theta_0\)</span> is the true value of the parameters, then the following holds,</p>
<div class="math notranslate nohighlight" id="equation-eqsmm-theta-plim">
<span class="eqno">(34)<a class="headerlink" href="#equation-eqsmm-theta-plim" title="Permalink to this equation">#</a></span>\[    \begin{equation}
      \text{plim}_{S\rightarrow\infty}\sqrt{S}\left(\hat{\theta}_{SMM} - \theta_0\right) \sim \text{N}\left(0, \left[d(\tilde{x},x|\theta)^T W d(\tilde{x},x|\theta)\right]^{-1}\right)
    \end{equation}\]</div>
<p>where <span class="math notranslate nohighlight">\(W\)</span> is the optimal weighting matrix from the SMM criterion function. The SMM estimator for the variance-covariance matrix <span class="math notranslate nohighlight">\(\hat{\Sigma}_{SMM}\)</span> of the parameter vector <span class="math notranslate nohighlight">\(\hat{\theta}_{SMM}\)</span> is the following.</p>
<div class="math notranslate nohighlight" id="equation-eqsmm-sigmahat">
<span class="eqno">(35)<a class="headerlink" href="#equation-eqsmm-sigmahat" title="Permalink to this equation">#</a></span>\[    \begin{equation}
      \hat{\Sigma}_{SMM} = \frac{1}{S}\left[d(\tilde{x},x|\theta)^T W d(\tilde{x},x|\theta)\right]^{-1}
    \end{equation}\]</div>
<p>In the examples below, we will use a finite difference method to compute numerical versions of the Jacobian matrix <span class="math notranslate nohighlight">\(d(\tilde{x},x|\theta)\)</span>. The following is a first-order forward finite difference numerical approximation of the first derivative of a function.</p>
<div class="math notranslate nohighlight" id="equation-eqsmm-finitediff-1">
<span class="eqno">(36)<a class="headerlink" href="#equation-eqsmm-finitediff-1" title="Permalink to this equation">#</a></span>\[    f'(x_0) = \lim_{h\rightarrow 0} \frac{f(x_0 + h) - f(x_0)}{h}\]</div>
<p>The following is a centered second-order finite difference numerical approximation of the derivative of a function. (See <a class="reference external" href="https://github.com/UC-MACSS/persp-model-econ_W19/blob/master/Notes/ACME_NumDiff.pdf">BYU ACME numerical differentiation lab</a> for more details.)</p>
<div class="math notranslate nohighlight" id="equation-eqsmm-finitediff-2">
<span class="eqno">(37)<a class="headerlink" href="#equation-eqsmm-finitediff-2" title="Permalink to this equation">#</a></span>\[    f'(x_0) \approx \frac{f(x_0 + h) - f(x_0 - h)}{2h}\]</div>
</section>
<section id="code-examples">
<span id="secsmm-codeexmp"></span><h2>Code Examples<a class="headerlink" href="#code-examples" title="Permalink to this heading">#</a></h2>
<p>In this section, we will use SMM to estimate parameters of the models from the <a class="reference internal" href="MaxLikelihood.html#chap-maxlikeli"><span class="std std-ref">Maximum Likelihood Estimation</span></a> chapter and from the <a class="reference internal" href="GMM.html#chap-gmm"><span class="std std-ref">Generalized Method of Moments Estimation</span></a> chapter.</p>
<section id="fitting-a-truncated-normal-to-intermediate-macroeconomics-test-scores">
<span id="secsmm-codeexmp-macrtest"></span><h3>Fitting a truncated normal to intermediate macroeconomics test scores<a class="headerlink" href="#fitting-a-truncated-normal-to-intermediate-macroeconomics-test-scores" title="Permalink to this heading">#</a></h3>
<p>Let’s revisit the problem from the MLE and GMM notebooks of fitting a truncated normal distribution to intermediate macroeconomics test scores. The data are in the text file <a class="reference external" href="https://github.com/OpenSourceEcon/CompMethods/blob/main/data/smm/Econ381totpts.txt"><code class="docutils literal notranslate"><span class="pre">Econ381totpts.txt</span></code></a>. Recall that these test scores are between 0 and 450. <a class="reference internal" href="#figsmm-econscoretruncnorm"><span class="std std-numref">Figure 3</span></a> below shows a histogram of the data, as well as three truncated normal PDF’s with different values for <span class="math notranslate nohighlight">\(\mu\)</span> and <span class="math notranslate nohighlight">\(\sigma\)</span>. The black line is the maximum likelihood estimate of <span class="math notranslate nohighlight">\(\mu\)</span> and <span class="math notranslate nohighlight">\(\sigma\)</span> of the truncated normal pdf from the <a class="reference internal" href="MaxLikelihood.html#chap-maxlikeli"><span class="std std-ref">Maximum Likelihood Estimation</span></a> chapter. The red, green, and black lines are just the PDF’s of two “arbitrarily” chosen combinations of the truncated normal parameters <span class="math notranslate nohighlight">\(\mu\)</span> and <span class="math notranslate nohighlight">\(\sigma\)</span>.<a class="footnote-reference brackets" href="#truncnorm" id="id11" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a></p>
<div class="cell tag_hide-input tag_remove-output docutils container">
<details class="hide above-input">
<summary aria-label="Toggle hidden content">
<span class="collapsed">Show code cell source</span>
<span class="expanded">Hide code cell source</span>
</summary>
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Import the necessary libraries</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy.stats</span> <span class="k">as</span> <span class="nn">sts</span>
<span class="kn">import</span> <span class="nn">requests</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">mpl_toolkits.mplot3d</span> <span class="kn">import</span> <span class="n">Axes3D</span>


<span class="c1"># Define function that generates values of a normal pdf</span>
<span class="k">def</span> <span class="nf">trunc_norm_pdf</span><span class="p">(</span><span class="n">xvals</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">cut_lb</span><span class="p">,</span> <span class="n">cut_ub</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    --------------------------------------------------------------------</span>
<span class="sd">    Generate pdf values from the normal pdf with mean mu and standard</span>
<span class="sd">    deviation sigma. If the cutoff is given, then the PDF values are</span>
<span class="sd">    inflated upward to reflect the zero probability on values above the</span>
<span class="sd">    cutoff. If there is no cutoff given, this function does the same</span>
<span class="sd">    thing as sp.stats.norm.pdf(x, loc=mu, scale=sigma).</span>
<span class="sd">    --------------------------------------------------------------------</span>
<span class="sd">    INPUTS:</span>
<span class="sd">    xvals  = (N,) vector, values of the normally distributed random</span>
<span class="sd">             variable</span>
<span class="sd">    mu     = scalar, mean of the normally distributed random variable</span>
<span class="sd">    sigma  = scalar &gt; 0, standard deviation of the normally distributed</span>
<span class="sd">             random variable</span>
<span class="sd">    cut_lb = scalar or string, =&#39;None&#39; if no cutoff is given, otherwise</span>
<span class="sd">             is scalar lower bound value of distribution. Values below</span>
<span class="sd">             this value have zero probability</span>
<span class="sd">    cut_ub = scalar or string, =&#39;None&#39; if no cutoff is given, otherwise</span>
<span class="sd">             is scalar upper bound value of distribution. Values above</span>
<span class="sd">             this value have zero probability</span>

<span class="sd">    OTHER FUNCTIONS AND FILES CALLED BY THIS FUNCTION: None</span>

<span class="sd">    OBJECTS CREATED WITHIN FUNCTION:</span>
<span class="sd">    prob_notcut = scalar</span>
<span class="sd">    pdf_vals = (N,) vector, normal PDF values for mu and sigma</span>
<span class="sd">               corresponding to xvals data</span>

<span class="sd">    FILES CREATED BY THIS FUNCTION: None</span>

<span class="sd">    RETURNS: pdf_vals</span>
<span class="sd">    --------------------------------------------------------------------</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">cut_ub</span> <span class="o">==</span> <span class="s1">&#39;None&#39;</span> <span class="ow">and</span> <span class="n">cut_lb</span> <span class="o">==</span> <span class="s1">&#39;None&#39;</span><span class="p">:</span>
        <span class="n">prob_notcut</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="k">elif</span> <span class="n">cut_ub</span> <span class="o">==</span> <span class="s1">&#39;None&#39;</span> <span class="ow">and</span> <span class="n">cut_lb</span> <span class="o">!=</span> <span class="s1">&#39;None&#39;</span><span class="p">:</span>
        <span class="n">prob_notcut</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">sts</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">cut_lb</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">mu</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">sigma</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">cut_ub</span> <span class="o">!=</span> <span class="s1">&#39;None&#39;</span> <span class="ow">and</span> <span class="n">cut_lb</span> <span class="o">==</span> <span class="s1">&#39;None&#39;</span><span class="p">:</span>
        <span class="n">prob_notcut</span> <span class="o">=</span> <span class="n">sts</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">cut_ub</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">mu</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">sigma</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">cut_ub</span> <span class="o">!=</span> <span class="s1">&#39;None&#39;</span> <span class="ow">and</span> <span class="n">cut_lb</span> <span class="o">!=</span> <span class="s1">&#39;None&#39;</span><span class="p">:</span>
        <span class="n">prob_notcut</span> <span class="o">=</span> <span class="p">(</span><span class="n">sts</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">cut_ub</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">mu</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">sigma</span><span class="p">)</span> <span class="o">-</span>
                       <span class="n">sts</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">cut_lb</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">mu</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">sigma</span><span class="p">))</span>

    <span class="n">pdf_vals</span>    <span class="o">=</span> <span class="p">((</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">sigma</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span> <span class="o">*</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span> <span class="o">-</span> <span class="p">(</span><span class="n">xvals</span> <span class="o">-</span> <span class="n">mu</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">sigma</span><span class="o">**</span><span class="mi">2</span><span class="p">)))</span> <span class="o">/</span>
                    <span class="n">prob_notcut</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">pdf_vals</span>


<span class="c1"># Download and save the data file Econ381totpts.txt</span>
<span class="n">url</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;https://raw.githubusercontent.com/OpenSourceEcon/CompMethods/&#39;</span> <span class="o">+</span>
       <span class="s1">&#39;main/data/smm/Econ381totpts.txt&#39;</span><span class="p">)</span>
<span class="n">data_file</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">allow_redirects</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="nb">open</span><span class="p">(</span><span class="s1">&#39;../../../data/smm/Econ381totpts.txt&#39;</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">data_file</span><span class="o">.</span><span class="n">content</span><span class="p">)</span>

<span class="c1"># Load the data as a NumPy array</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="s1">&#39;../../../data/smm/Econ381totpts.txt&#39;</span><span class="p">)</span>

<span class="n">num_bins</span> <span class="o">=</span> <span class="mi">30</span>
<span class="n">count</span><span class="p">,</span> <span class="n">bins</span><span class="p">,</span> <span class="n">ignored</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span>
    <span class="n">data</span><span class="p">,</span> <span class="n">num_bins</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;data&#39;</span>
<span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Econ 381 scores: 2011-2012&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;Total points&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;Percent of scores&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">550</span><span class="p">])</span>  <span class="c1"># This gives the xmin and xmax to be plotted&quot;</span>

<span class="c1"># Plot smooth line with distribution 1</span>
<span class="n">dist_pts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">450</span><span class="p">,</span> <span class="mi">500</span><span class="p">)</span>
<span class="n">mu_1</span> <span class="o">=</span> <span class="mi">300</span>
<span class="n">sig_1</span> <span class="o">=</span> <span class="mi">30</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">dist_pts</span><span class="p">,</span> <span class="n">trunc_norm_pdf</span><span class="p">(</span><span class="n">dist_pts</span><span class="p">,</span> <span class="n">mu_1</span><span class="p">,</span> <span class="n">sig_1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">450</span><span class="p">),</span>
         <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;$\mu$=</span><span class="si">{</span><span class="n">mu_1</span><span class="si">}</span><span class="s2">,$\sigma$=</span><span class="si">{</span><span class="n">sig_1</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="c1"># Plot smooth line with distribution 2</span>
<span class="n">mu_2</span> <span class="o">=</span> <span class="mi">400</span>
<span class="n">sig_2</span> <span class="o">=</span> <span class="mi">70</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">dist_pts</span><span class="p">,</span> <span class="n">trunc_norm_pdf</span><span class="p">(</span><span class="n">dist_pts</span><span class="p">,</span> <span class="n">mu_2</span><span class="p">,</span> <span class="n">sig_2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">450</span><span class="p">),</span>
         <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;green&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;$\mu$=</span><span class="si">{</span><span class="n">mu_2</span><span class="si">}</span><span class="s2">,$\sigma$=</span><span class="si">{</span><span class="n">sig_2</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="c1"># Plot smooth line with distribution 3</span>
<span class="n">mu_3</span> <span class="o">=</span> <span class="mi">558</span>
<span class="n">sig_3</span> <span class="o">=</span> <span class="mi">176</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">dist_pts</span><span class="p">,</span> <span class="n">trunc_norm_pdf</span><span class="p">(</span><span class="n">dist_pts</span><span class="p">,</span> <span class="n">mu_3</span><span class="p">,</span> <span class="n">sig_3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">450</span><span class="p">),</span>
         <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;$\mu$=</span><span class="si">{</span><span class="n">mu_3</span><span class="si">}</span><span class="s2">,$\sigma$=</span><span class="si">{</span><span class="n">sig_3</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;upper left&#39;</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
</details>
</div>
<figure class="align-default" id="figsmm-econscoretruncnorm">
<a class="reference internal image-reference" href="../_images/Econ381scores_truncnorm.png"><img alt="../_images/Econ381scores_truncnorm.png" src="../_images/Econ381scores_truncnorm.png" style="height: 500px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 3 </span><span class="caption-text">Macroeconomic midterm scores and three truncated normal distributions</span><a class="headerlink" href="#figsmm-econscoretruncnorm" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<section id="two-moments-identity-weighting-matrix">
<span id="secsmm-codeexmp-macrtest-2mi"></span><h4>Two moments, identity weighting matrix<a class="headerlink" href="#two-moments-identity-weighting-matrix" title="Permalink to this heading">#</a></h4>
<p>Let’s try estimating the parameters <span class="math notranslate nohighlight">\(\mu\)</span> and <span class="math notranslate nohighlight">\(\sigma\)</span> from the truncated normal distribution by SMM, assuming that we know the cutoff values for the distribution of scores <span class="math notranslate nohighlight">\(c_{lb}=0\)</span> and <span class="math notranslate nohighlight">\(c_{ub}=450\)</span>. What moments should we use? Let’s try the mean and variance of the data. These two statistics of the data are defined by:</p>
<div class="math notranslate nohighlight">
\[ mean(scores_i) = \frac{1}{N}\sum_{i=1}^N scores_i \]</div>
<div class="math notranslate nohighlight">
\[ var(scores_i) = \frac{1}{N-1}\sum_{i=1}^{N} \left(scores_i - mean(scores_i)\right)^2 \]</div>
<p>So the data moment vector <span class="math notranslate nohighlight">\(m(x)\)</span> for SMM has two elements <span class="math notranslate nohighlight">\(R=2\)</span> and is the following.</p>
<div class="math notranslate nohighlight">
\[\begin{split} m(scores_i) \equiv \begin{bmatrix} mean(scores_i) \\ var(scores_i) \end{bmatrix} \end{split}\]</div>
<p>And the model moment vector <span class="math notranslate nohighlight">\(m(x|\theta)\)</span> for SMM is the following.</p>
<div class="math notranslate nohighlight">
\[\begin{split} m(scores_i|\mu,\sigma) \equiv \begin{bmatrix} mean(scores_i|\mu,\sigma) \\ var(scores_i|\mu,\sigma) \end{bmatrix} \end{split}\]</div>
<p>But let’s assume that we need to simulate the data from the model (test scores) <span class="math notranslate nohighlight">\(S\)</span> times in order to get the model moments. In this case, we don’t need to simulate. But we will do so to show how SMM works.</p>
<div class="cell tag_remove-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Import packages and load the data</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">numpy.random</span> <span class="k">as</span> <span class="nn">rnd</span>
<span class="kn">import</span> <span class="nn">numpy.linalg</span> <span class="k">as</span> <span class="nn">lin</span>
<span class="kn">import</span> <span class="nn">scipy.stats</span> <span class="k">as</span> <span class="nn">sts</span>
<span class="kn">import</span> <span class="nn">scipy.integrate</span> <span class="k">as</span> <span class="nn">intgr</span>
<span class="kn">import</span> <span class="nn">scipy.optimize</span> <span class="k">as</span> <span class="nn">opt</span>
<span class="kn">import</span> <span class="nn">matplotlib</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">mpl_toolkits.mplot3d</span> <span class="kn">import</span> <span class="n">Axes3D</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">cm</span>
<span class="n">cmap1</span> <span class="o">=</span> <span class="n">matplotlib</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="s1">&#39;summer&#39;</span><span class="p">)</span>

<span class="c1"># Download and save the data file Econ381totpts.txt</span>
<span class="n">url</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;https://raw.githubusercontent.com/OpenSourceEcon/CompMethods/&#39;</span> <span class="o">+</span>
       <span class="s1">&#39;main/data/smm/Econ381totpts.txt&#39;</span><span class="p">)</span>
<span class="n">data_file</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">allow_redirects</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="nb">open</span><span class="p">(</span><span class="s1">&#39;../../../data/smm/Econ381totpts.txt&#39;</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">data_file</span><span class="o">.</span><span class="n">content</span><span class="p">)</span>

<span class="c1"># Load the data as a NumPy array</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="s1">&#39;../../../data/smm/Econ381totpts.txt&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Let random variable <span class="math notranslate nohighlight">\(y\sim N(\mu,\sigma)\)</span> be distributed normally with mean <span class="math notranslate nohighlight">\(\mu\)</span> and standard deviation <span class="math notranslate nohighlight">\(\sigma\)</span> with PDF given by <span class="math notranslate nohighlight">\(\phi(y|\mu,\sigma)\)</span> and CDF given by <span class="math notranslate nohighlight">\(\Phi(y|\mu,\sigma)\)</span>. The truncated normal distribution of random variable <span class="math notranslate nohighlight">\(x\in(a,b)\)</span> based on <span class="math notranslate nohighlight">\(y\)</span> but with cutoff values of <span class="math notranslate nohighlight">\(a\geq -\infty\)</span> as a lower bound and <span class="math notranslate nohighlight">\(a &lt; b\leq\infty\)</span> as an upper bound has the following probability density function.</p>
<div class="math notranslate nohighlight">
\[\begin{split} f(x|\mu,\sigma,a,b) = \begin{cases} 0 \quad\text{if}\quad x\leq a \\ \frac{\phi(x|\mu,\sigma)}{\Phi(b|\mu,\sigma) - \Phi(a|\mu,\sigma)}\quad\text{if}\quad a &lt; x &lt; b \\ 0 \quad\text{if}\quad x\geq b \end{cases} \end{split}\]</div>
<p>The CDF of the truncated normal can be shown to be the following:</p>
<div class="math notranslate nohighlight">
\[\begin{split} F(x|\mu,\sigma,a,b) = \begin{cases} 0 \quad\text{if}\quad x\leq a \\ \frac{\Phi(x|\mu,\sigma) - \Phi(a|\mu,\sigma)}{\Phi(b|\mu,\sigma) - \Phi(a|\mu,\sigma)}\quad\text{if}\quad a &lt; x &lt; b \\ 0 \quad\text{if}\quad x\geq b \end{cases} \end{split}\]</div>
<p>The inverse CDF of the truncated normal takes a value <span class="math notranslate nohighlight">\(p\)</span> between 0 and 1 and solves for the value of <span class="math notranslate nohighlight">\(x\)</span> for which <span class="math notranslate nohighlight">\(p=F(x|\mu,\sigma,a,b)\)</span>. The expression for the inverse CDF of the truncated normal is the following:</p>
<div class="math notranslate nohighlight">
\[ x = \Phi^{-1}(z|\mu,\sigma) \quad\text{where}\quad z = p\Bigl[\Phi(b|\mu,\sigma) - \Phi(a|\mu,\sigma)\Bigr] + \Phi(a|\mu,\sigma) \]</div>
<p>Note that <span class="math notranslate nohighlight">\(z\)</span> is just a transformation of <span class="math notranslate nohighlight">\(p\)</span> such that <span class="math notranslate nohighlight">\(z\sim U\Bigl(\Phi^{-1}(a|\mu,\sigma), \Phi^{-1}(b|\mu,\sigma)\Bigr)\)</span>.</p>
<p>The following code for <code class="docutils literal notranslate"><span class="pre">trunc_norm_pdf()</span></code> is a function that returns the probability distribution function value of random variable value <span class="math notranslate nohighlight">\(x\)</span> given parameters <span class="math notranslate nohighlight">\(\mu\)</span>, <span class="math notranslate nohighlight">\(\sigma\)</span>, <span class="math notranslate nohighlight">\(c_{lb}\)</span>, <span class="math notranslate nohighlight">\(c_{ub}\)</span>.</p>
<div class="cell tag_remove-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">trunc_norm_pdf</span><span class="p">(</span><span class="n">xvals</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">cut_lb</span><span class="p">,</span> <span class="n">cut_ub</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    --------------------------------------------------------------------</span>
<span class="sd">    Generate pdf values from the normal pdf with mean mu and standard</span>
<span class="sd">    deviation sigma. If the cutoff is given, then the PDF values are</span>
<span class="sd">    inflated upward to reflect the zero probability on values above the</span>
<span class="sd">    cutoff. If there is no cutoff given, this function does the same</span>
<span class="sd">    thing as sp.stats.norm.pdf(x, loc=mu, scale=sigma).</span>
<span class="sd">    --------------------------------------------------------------------</span>
<span class="sd">    INPUTS:</span>
<span class="sd">    xvals  = (N,) vector, values of the normally distributed random</span>
<span class="sd">             variable</span>
<span class="sd">    mu     = scalar, mean of the normally distributed random variable</span>
<span class="sd">    sigma  = scalar &gt; 0, standard deviation of the normally distributed</span>
<span class="sd">             random variable</span>
<span class="sd">    cut_lb = scalar or string, =&#39;None&#39; if no cutoff is given, otherwise</span>
<span class="sd">             is scalar lower bound value of distribution. Values below</span>
<span class="sd">             this value have zero probability</span>
<span class="sd">    cut_ub = scalar or string, =&#39;None&#39; if no cutoff is given, otherwise</span>
<span class="sd">             is scalar upper bound value of distribution. Values above</span>
<span class="sd">             this value have zero probability</span>

<span class="sd">    OTHER FUNCTIONS AND FILES CALLED BY THIS FUNCTION: None</span>

<span class="sd">    OBJECTS CREATED WITHIN FUNCTION:</span>
<span class="sd">    prob_notcut = scalar</span>
<span class="sd">    pdf_vals = (N,) vector, normal PDF values for mu and sigma</span>
<span class="sd">               corresponding to xvals data</span>

<span class="sd">    FILES CREATED BY THIS FUNCTION: None</span>

<span class="sd">    RETURNS: pdf_vals</span>
<span class="sd">    --------------------------------------------------------------------</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">cut_ub</span> <span class="o">==</span> <span class="s1">&#39;None&#39;</span> <span class="ow">and</span> <span class="n">cut_lb</span> <span class="o">==</span> <span class="s1">&#39;None&#39;</span><span class="p">:</span>
        <span class="n">prob_notcut</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="k">elif</span> <span class="n">cut_ub</span> <span class="o">==</span> <span class="s1">&#39;None&#39;</span> <span class="ow">and</span> <span class="n">cut_lb</span> <span class="o">!=</span> <span class="s1">&#39;None&#39;</span><span class="p">:</span>
        <span class="n">prob_notcut</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">sts</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">cut_lb</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">mu</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">sigma</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">cut_ub</span> <span class="o">!=</span> <span class="s1">&#39;None&#39;</span> <span class="ow">and</span> <span class="n">cut_lb</span> <span class="o">==</span> <span class="s1">&#39;None&#39;</span><span class="p">:</span>
        <span class="n">prob_notcut</span> <span class="o">=</span> <span class="n">sts</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">cut_ub</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">mu</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">sigma</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">cut_ub</span> <span class="o">!=</span> <span class="s1">&#39;None&#39;</span> <span class="ow">and</span> <span class="n">cut_lb</span> <span class="o">!=</span> <span class="s1">&#39;None&#39;</span><span class="p">:</span>
        <span class="n">prob_notcut</span> <span class="o">=</span> <span class="p">(</span><span class="n">sts</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">cut_ub</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">mu</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">sigma</span><span class="p">)</span> <span class="o">-</span>
                       <span class="n">sts</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">cut_lb</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">mu</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">sigma</span><span class="p">))</span>

    <span class="n">pdf_vals</span> <span class="o">=</span> <span class="p">(</span>
        <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">sigma</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span> <span class="o">*</span>
         <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span> <span class="o">-</span> <span class="p">(</span><span class="n">xvals</span> <span class="o">-</span> <span class="n">mu</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">sigma</span><span class="o">**</span><span class="mi">2</span><span class="p">)))</span> <span class="o">/</span>
        <span class="n">prob_notcut</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">pdf_vals</span>
</pre></div>
</div>
</div>
</div>
<p>The following code <code class="docutils literal notranslate"><span class="pre">trunc_norm_draws</span></code> is a function that draws <span class="math notranslate nohighlight">\(S\)</span> simulations of <span class="math notranslate nohighlight">\(N\)</span> observations of the random variable <span class="math notranslate nohighlight">\(x_{n,s}\)</span> that is distributed truncated normal. This function takes as an input an <span class="math notranslate nohighlight">\(N\times S\)</span> matrix of uniform distributed values <span class="math notranslate nohighlight">\(u_{n,s}\sim U(0,1)\)</span>.</p>
<div class="cell tag_remove-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">trunc_norm_draws</span><span class="p">(</span><span class="n">unif_vals</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">cut_lb</span><span class="p">,</span> <span class="n">cut_ub</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    --------------------------------------------------------------------</span>
<span class="sd">    Draw (N x S) matrix of random draws from a truncated normal</span>
<span class="sd">    distribution based on a normal distribution with mean mu and</span>
<span class="sd">    standard deviation sigma and cutoffs (cut_lb, cut_ub). These draws</span>
<span class="sd">    correspond to an (N x S) matrix of randomly generated draws from a</span>
<span class="sd">    uniform distribution U(0,1).</span>
<span class="sd">    --------------------------------------------------------------------</span>
<span class="sd">    INPUTS:</span>
<span class="sd">    unif_vals = (N, S) matrix, (N,) vector, or scalar in (0,1), random</span>
<span class="sd">                draws from uniform U(0,1) distribution</span>
<span class="sd">    mu        = scalar, mean of the nontruncated normal distribution</span>
<span class="sd">                from which the truncated normal is derived</span>
<span class="sd">    sigma     = scalar &gt; 0, standard deviation of the nontruncated</span>
<span class="sd">                normal distribution from which the truncated normal is</span>
<span class="sd">                derived</span>
<span class="sd">    cut_lb    = scalar or string, =&#39;None&#39; if no lower bound cutoff is</span>
<span class="sd">                given, otherwise is scalar lower bound value of</span>
<span class="sd">                distribution. Values below this cutoff have zero</span>
<span class="sd">                probability</span>
<span class="sd">    cut_ub    = scalar or string, =&#39;None&#39; if no upper bound cutoff is</span>
<span class="sd">                given, otherwise is scalar lower bound value of</span>
<span class="sd">                distribution. Values below this cutoff have zero</span>
<span class="sd">                probability</span>

<span class="sd">    OTHER FUNCTIONS AND FILES CALLED BY THIS FUNCTION:</span>
<span class="sd">        scipy.stats.norm()</span>

<span class="sd">    OBJECTS CREATED WITHIN FUNCTION:</span>
<span class="sd">    cut_ub_cdf  = scalar in [0, 1], cdf of N(mu, sigma) at upper bound</span>
<span class="sd">                  cutoff of truncated normal distribution</span>
<span class="sd">    cut_lb_cdf  = scalar in [0, 1], cdf of N(mu, sigma) at lower bound</span>
<span class="sd">                  cutoff of truncated normal distribution</span>
<span class="sd">    unif2_vals  = (N, S) matrix, (N,) vector, or scalar in (0,1),</span>
<span class="sd">                  rescaled uniform derived from original.</span>
<span class="sd">    tnorm_draws = (N, S) matrix, (N,) vector, or scalar in (0,1),</span>
<span class="sd">                  values drawn from truncated normal PDF with base</span>
<span class="sd">                  normal distribution N(mu, sigma) and cutoffs</span>
<span class="sd">                  (cut_lb, cut_ub)</span>

<span class="sd">    FILES CREATED BY THIS FUNCTION: None</span>

<span class="sd">    RETURNS: tnorm_draws</span>
<span class="sd">    --------------------------------------------------------------------</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># No cutoffs: truncated normal = normal</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">cut_lb</span> <span class="o">==</span> <span class="kc">None</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">cut_ub</span> <span class="o">==</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">cut_ub_cdf</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="n">cut_lb_cdf</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="c1"># Lower bound truncation, no upper bound truncation</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">cut_lb</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">cut_ub</span> <span class="o">==</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">cut_ub_cdf</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="n">cut_lb_cdf</span> <span class="o">=</span> <span class="n">sts</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">cut_lb</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">mu</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">sigma</span><span class="p">)</span>
    <span class="c1"># Upper bound truncation, no lower bound truncation</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">cut_lb</span> <span class="o">==</span> <span class="kc">None</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">cut_ub</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">cut_ub_cdf</span> <span class="o">=</span> <span class="n">sts</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">cut_ub</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">mu</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">sigma</span><span class="p">)</span>
        <span class="n">cut_lb_cdf</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="c1"># Lower bound and upper bound truncation</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">cut_lb</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">cut_ub</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">cut_ub_cdf</span> <span class="o">=</span> <span class="n">sts</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">cut_ub</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">mu</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">sigma</span><span class="p">)</span>
        <span class="n">cut_lb_cdf</span> <span class="o">=</span> <span class="n">sts</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">cut_lb</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">mu</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">sigma</span><span class="p">)</span>

    <span class="n">unif2_vals</span> <span class="o">=</span> <span class="n">unif_vals</span> <span class="o">*</span> <span class="p">(</span><span class="n">cut_ub_cdf</span> <span class="o">-</span> <span class="n">cut_lb_cdf</span><span class="p">)</span> <span class="o">+</span> <span class="n">cut_lb_cdf</span>
    <span class="n">tnorm_draws</span> <span class="o">=</span> <span class="n">sts</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="n">unif2_vals</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">mu</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">sigma</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">tnorm_draws</span>
</pre></div>
</div>
</div>
</div>
<p>What would one simulation of 161 test scores look like from a truncated normal with mean <span class="math notranslate nohighlight">\(\mu=300\)</span>, <span class="math notranslate nohighlight">\(\sigma=30\)</span>?</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">mu_1</span> <span class="o">=</span> <span class="mf">300.0</span>
<span class="n">sig_1</span> <span class="o">=</span> <span class="mf">30.0</span>
<span class="n">cut_lb_1</span> <span class="o">=</span> <span class="mf">0.0</span>
<span class="n">cut_ub_1</span> <span class="o">=</span> <span class="mf">450.0</span>
<span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="o">=</span><span class="mi">1975</span><span class="p">)</span>  <span class="c1"># Set seed so the simulation values are always the same</span>
<span class="n">unif_vals_1</span> <span class="o">=</span> <span class="n">sts</span><span class="o">.</span><span class="n">uniform</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">161</span><span class="p">)</span>
<span class="n">draws_1</span> <span class="o">=</span> <span class="n">trunc_norm_draws</span><span class="p">(</span><span class="n">unif_vals_1</span><span class="p">,</span> <span class="n">mu_1</span><span class="p">,</span> <span class="n">sig_1</span><span class="p">,</span> <span class="n">cut_lb_1</span><span class="p">,</span> <span class="n">cut_ub_1</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Mean of simulated score =&#39;</span><span class="p">,</span> <span class="n">draws_1</span><span class="o">.</span><span class="n">mean</span><span class="p">())</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Variance of simulated scores =&#39;</span><span class="p">,</span> <span class="n">draws_1</span><span class="o">.</span><span class="n">var</span><span class="p">())</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Standard deviation of simulated scores =&#39;</span><span class="p">,</span> <span class="n">draws_1</span><span class="o">.</span><span class="n">std</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Mean of simulated score = 300.17445658136046
Variance of simulated scores = 1000.626705029347
Standard deviation of simulated scores = 31.632684126222152
</pre></div>
</div>
</div>
</div>
<div class="cell tag_remove-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Plot data histogram vs. simulated data histogram</span>
<span class="n">count_d</span><span class="p">,</span> <span class="n">bins_d</span><span class="p">,</span> <span class="n">ignored_d</span> <span class="o">=</span> \
    <span class="n">plt</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">,</span>
             <span class="n">linewidth</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Data&#39;</span><span class="p">)</span>
<span class="n">count_m</span><span class="p">,</span> <span class="n">bins_m</span><span class="p">,</span> <span class="n">ignored_m</span> <span class="o">=</span> \
    <span class="n">plt</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">draws_1</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">,</span>
             <span class="n">linewidth</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Simulated data&#39;</span><span class="p">)</span>
<span class="n">xvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">450</span><span class="p">,</span> <span class="mi">500</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xvals</span><span class="p">,</span> <span class="n">trunc_norm_pdf</span><span class="p">(</span><span class="n">xvals</span><span class="p">,</span> <span class="n">mu_1</span><span class="p">,</span> <span class="n">sig_1</span><span class="p">,</span> <span class="n">cut_lb_1</span><span class="p">,</span> <span class="n">cut_ub_1</span><span class="p">),</span>
         <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;PDF, simulated data&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Econ 381 scores: 2011-2012&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Total points&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Percent of scores&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">550</span><span class="p">])</span>  <span class="c1"># This gives the xmin and xmax to be plotted&quot;</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;upper left&#39;</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<figure class="align-default" id="figsmm-econscoresim1">
<a class="reference internal image-reference" href="../_images/Econ381scores_sim1.png"><img alt="../_images/Econ381scores_sim1.png" src="../_images/Econ381scores_sim1.png" style="height: 500px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 4 </span><span class="caption-text">Histograms of one simulation of 161 Econ 381 test scores (2011-2012) from arbitrary truncated normal distribution compared to data</span><a class="headerlink" href="#figsmm-econscoresim1" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>From that simulation, we can calculate moments from the simulated data just like we did from the actual data. The following function <code class="docutils literal notranslate"><span class="pre">data_moments2()</span></code> computes the mean and the variance of the simulated data <span class="math notranslate nohighlight">\(x\)</span>, where <span class="math notranslate nohighlight">\(x\)</span> is an <span class="math notranslate nohighlight">\(N\times S\)</span> matrix of <span class="math notranslate nohighlight">\(S\)</span> simulations of <span class="math notranslate nohighlight">\(N\)</span> observations each.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">data_moments2</span><span class="p">(</span><span class="n">xvals</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    --------------------------------------------------------------------</span>
<span class="sd">    This function computes the two data moments for SMM</span>
<span class="sd">    (mean(data), variance(data)) from both the actual data and from the</span>
<span class="sd">    simulated data.</span>
<span class="sd">    --------------------------------------------------------------------</span>
<span class="sd">    INPUTS:</span>
<span class="sd">    xvals = (N, S) matrix or (N,) vector, or scalar in (cut_lb, cut_ub),</span>
<span class="sd">            test scores data, either real world or simulated. Real world</span>
<span class="sd">            data will come in the form (N,). Simulated data comes in the</span>
<span class="sd">            form (N,) or (N, S).</span>

<span class="sd">    OTHER FUNCTIONS AND FILES CALLED BY THIS FUNCTION: None</span>

<span class="sd">    OBJECTS CREATED WITHIN FUNCTION:</span>
<span class="sd">    mean_data = scalar or (S,) vector, mean value of test scores data</span>
<span class="sd">    var_data  = scalar &gt; 0 or (S,) vector, variance of test scores data</span>

<span class="sd">    FILES CREATED BY THIS FUNCTION: None</span>

<span class="sd">    RETURNS: mean_data, var_data</span>
<span class="sd">    --------------------------------------------------------------------</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">xvals</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">mean_data</span> <span class="o">=</span> <span class="n">xvals</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="n">var_data</span> <span class="o">=</span> <span class="n">xvals</span><span class="o">.</span><span class="n">var</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">xvals</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">mean_data</span> <span class="o">=</span> <span class="n">xvals</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">var_data</span> <span class="o">=</span> <span class="n">xvals</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">mean_data</span><span class="p">,</span> <span class="n">var_data</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">mean_data</span><span class="p">,</span> <span class="n">var_data</span> <span class="o">=</span> <span class="n">data_moments2</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Data mean =&#39;</span><span class="p">,</span> <span class="n">mean_data</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Data variance =&#39;</span><span class="p">,</span> <span class="n">var_data</span><span class="p">)</span>
<span class="n">mean_sim</span><span class="p">,</span> <span class="n">var_sim</span> <span class="o">=</span> <span class="n">data_moments2</span><span class="p">(</span><span class="n">draws_1</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Sim. mean =&#39;</span><span class="p">,</span> <span class="n">mean_sim</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Sim. variance =&#39;</span><span class="p">,</span> <span class="n">var_sim</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Data mean = 341.90869565217395
Data variance = 7827.997292398056
Sim. mean = 300.17445658136046
Sim. variance = 1000.626705029347
</pre></div>
</div>
</div>
</div>
<p>We can also simulate many <span class="math notranslate nohighlight">\((S)\)</span> data sets of test scores, each with <span class="math notranslate nohighlight">\(N=161\)</span> test scores. The estimate of the model moments will be the average of the simulated data moments across the simulations.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">N</span> <span class="o">=</span> <span class="mi">161</span>
<span class="n">S</span> <span class="o">=</span> <span class="mi">100</span>
<span class="n">mu_2</span> <span class="o">=</span> <span class="mf">300.0</span>
<span class="n">sig_2</span> <span class="o">=</span> <span class="mf">30.0</span>
<span class="n">cut_lb</span> <span class="o">=</span> <span class="mf">0.0</span>
<span class="n">cut_ub</span> <span class="o">=</span> <span class="mf">450.0</span>
<span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">25</span><span class="p">)</span>  <span class="c1"># Set the random number seed to get same answers every time</span>
<span class="n">unif_vals_2</span> <span class="o">=</span> <span class="n">sts</span><span class="o">.</span><span class="n">uniform</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">S</span><span class="p">))</span>
<span class="n">draws_2</span> <span class="o">=</span> <span class="n">trunc_norm_draws</span><span class="p">(</span><span class="n">unif_vals_2</span><span class="p">,</span> <span class="n">mu_2</span><span class="p">,</span> <span class="n">sig_2</span><span class="p">,</span>
                           <span class="n">cut_lb</span><span class="p">,</span> <span class="n">cut_ub</span><span class="p">)</span>

<span class="n">mean_sim</span><span class="p">,</span> <span class="n">var_sim</span> <span class="o">=</span> <span class="n">data_moments2</span><span class="p">(</span><span class="n">draws_2</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Mean test score in each simulation:&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">mean_sim</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Variance of test scores in each simulation:&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">var_sim</span><span class="p">)</span>
<span class="n">mean_mod</span> <span class="o">=</span> <span class="n">mean_sim</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
<span class="n">var_mod</span> <span class="o">=</span> <span class="n">var_sim</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Estimated model mean (avg. of means) =&#39;</span><span class="p">,</span> <span class="n">mean_mod</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Estimated model variance (avg. of variances) =&#39;</span><span class="p">,</span> <span class="n">var_mod</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Mean test score in each simulation:
[299.17667999 298.61052796 304.45608507 301.37072845 299.66868577
 303.44257561 298.68174796 297.94014672 297.47566228 299.63490045
 298.57207266 299.13235013 296.63826526 300.44460537 302.98678012
 301.09166082 302.89663118 301.50056988 299.56091107 301.94919604
 296.58486163 300.109284   303.35295389 300.4763979  298.52345697
 299.37526236 298.54462388 301.20756546 301.23182905 297.92082255
 302.0881712  300.37792528 302.69523093 298.92838232 296.03376169
 299.9335839  302.69026345 302.0934371  299.70288418 300.88610536
 304.86283252 299.10407269 303.11654222 302.07027394 299.29923542
 298.74552083 297.79965311 301.59852312 300.15616963 301.59864217
 295.52781074 303.98090953 300.31248226 301.44867717 297.78114307
 302.64825256 303.68061798 300.12495043 299.80104697 305.78334207
 300.95811329 297.94097772 303.02458302 300.24287686 305.55084554
 296.62551538 301.73820461 303.91841652 305.97485316 300.25235036
 298.6490962  299.80907094 301.66541992 298.66699545 298.68524191
 301.45696273 301.27407424 298.22269311 301.22887168 299.54314562
 299.85171183 299.26405411 298.87330671 301.59708796 298.46696222
 299.01431864 299.27736899 299.20186117 297.60298908 299.34134778
 296.56023236 300.36842728 299.81705203 300.234357   296.93063956
 301.60442391 299.68503428 298.32917874 300.93011523 298.78807296]

Variance of test scores in each simulation:
[ 854.27400514  793.0403989   841.76252205  819.86183015 1055.80239074
  834.52746835  955.01586149 1033.93476802  804.86989439  715.96784403
  927.66459495  594.40100934  974.32315671  903.2658217   877.78145497
  900.13017505  871.56069402  835.1365732   849.46651395  835.02582303
  939.66718613  654.80578245  998.41113837  815.81618606 1002.68353273
  907.56790563  724.85910396  813.70435378 1015.31786118  975.59759144
  888.63526849  881.81187368  842.94152651  976.74617301  978.23045295
  790.85144559  933.04687473  987.37433204  980.14458376 1003.34539581
  859.63957381 1050.9870203   901.66724764  967.15290016 1133.2532708
 1033.60468078  810.90856957  930.53152973  921.0020767   802.31271115
  928.68723732 1046.31773806  932.0434472  1025.05965686  951.23678849
  839.58583279  941.39252702  751.71431141  841.4610679  1021.10990195
  863.80405021  849.16404517  819.12655726 1095.10022731  848.76703098
  797.43467707  823.16623979 1056.73087072  821.12496192  917.86308975
  841.00526807  862.52415389  937.44315325  884.41413606  933.28154226
  864.67286651  992.96039373  856.4044805   868.37693837  954.32843377
  814.35548352  758.33184649  861.16008799  917.8168036   980.31470517
  821.32422902 1057.5979759   843.6883495   941.15291878  925.33449079
  778.30674576  856.47550771  920.80553617  902.19187292  918.9232
  880.47284712  841.07711245  925.82668059 1037.04590733  925.75216207]

Estimated model mean (avg. of means) = 300.28595134427394
Estimated model variance (avg. of variances) = 898.7468703753616
</pre></div>
</div>
</div>
</div>
<p>Our SMM model moments <span class="math notranslate nohighlight">\(\hat{m}(\tilde{scores}_i|\mu,\sigma)\)</span> are an estimate of the true models moments that we got in the GMM case by integrating using the PDF of the truncated normal distribution. Our SMM moments we got by simulating the data <span class="math notranslate nohighlight">\(S\)</span> times and taking the average of the simulated data moments across the simulations as our estimator of the model moments.</p>
<p>Define the error vector as the vector of percent deviations of the model moments from the data moments.</p>
<div class="math notranslate nohighlight">
\[ e(\tilde{scores}_i,scores_i|\mu,\sigma) \equiv \frac{\hat{m}(\tilde{scores}_i|\mu,\sigma) - m(scores_i)}{m(scores_i)} \]</div>
<p>The SMM estimator for this moment vector is the following.</p>
<div class="math notranslate nohighlight">
\[ (\hat{\mu}_{SMM},\hat{\sigma}_{SMM}) = (\mu,\sigma):\quad \min_{\mu,\sigma} e(\tilde{scores}_i,scores_i|\mu,\sigma)^T \, W \, e(\tilde{scores}_i,scores_i|\mu,\sigma) \]</div>
<p>Now let’s define a criterion function that takes as inputs the parameters and the estimator for the weighting matrix <span class="math notranslate nohighlight">\(\hat{W}\)</span>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">err_vec2</span><span class="p">(</span><span class="n">data_vals</span><span class="p">,</span> <span class="n">unif_vals</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">cut_lb</span><span class="p">,</span> <span class="n">cut_ub</span><span class="p">,</span> <span class="n">simple</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    --------------------------------------------------------------------</span>
<span class="sd">    This function computes the vector of moment errors (in percent</span>
<span class="sd">    deviation from the data moment vector) for SMM.</span>
<span class="sd">    --------------------------------------------------------------------</span>
<span class="sd">    INPUTS:</span>
<span class="sd">    data_vals = (N,) vector, test scores data</span>
<span class="sd">    unif_vals = (N, S) matrix, S simulations of N observations from</span>
<span class="sd">                uniform distribution U(0,1)</span>
<span class="sd">    mu        = scalar, mean of the nontruncated normal distribution</span>
<span class="sd">                from which the truncated normal is derived</span>
<span class="sd">    sigma     = scalar &gt; 0, standard deviation of the nontruncated</span>
<span class="sd">                normal distribution from which the truncated normal is</span>
<span class="sd">                derived</span>
<span class="sd">    cut_lb    = scalar or string, =&#39;None&#39; if no lower bound cutoff is</span>
<span class="sd">                given, otherwise is scalar lower bound value of</span>
<span class="sd">                distribution. Values below this cutoff have zero</span>
<span class="sd">                probability</span>
<span class="sd">    cut_ub    = scalar or string, =&#39;None&#39; if no upper bound cutoff is</span>
<span class="sd">                given, otherwise is scalar lower bound value of</span>
<span class="sd">                distribution. Values below this cutoff have zero</span>
<span class="sd">                probability</span>
<span class="sd">    simple    = boolean, =True if errors are simple difference, =False</span>
<span class="sd">                if errors are percent deviation from data moments</span>

<span class="sd">    OTHER FUNCTIONS AND FILES CALLED BY THIS FUNCTION:</span>
<span class="sd">        trunc_norm_draws()</span>
<span class="sd">        data_moments()</span>

<span class="sd">    OBJECTS CREATED WITHIN FUNCTION:</span>
<span class="sd">    mean_data  = scalar, mean value of data</span>
<span class="sd">    var_data   = scalar &gt; 0, variance of data</span>
<span class="sd">    moms_data  = (2, 1) matrix, column vector of two data moments</span>
<span class="sd">    mean_model = scalar, estimated mean value from model</span>
<span class="sd">    var_model  = scalar &gt; 0, estimated variance from model</span>
<span class="sd">    moms_model = (2, 1) matrix, column vector of two model moments</span>
<span class="sd">    err_vec    = (2, 1) matrix, column vector of two moment error</span>
<span class="sd">                 functions</span>

<span class="sd">    FILES CREATED BY THIS FUNCTION: None</span>

<span class="sd">    RETURNS: err_vec</span>
<span class="sd">    --------------------------------------------------------------------</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">sim_vals</span> <span class="o">=</span> <span class="n">trunc_norm_draws</span><span class="p">(</span><span class="n">unif_vals</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">cut_lb</span><span class="p">,</span> <span class="n">cut_ub</span><span class="p">)</span>
    <span class="n">mean_data</span><span class="p">,</span> <span class="n">var_data</span> <span class="o">=</span> <span class="n">data_moments2</span><span class="p">(</span><span class="n">data_vals</span><span class="p">)</span>
    <span class="n">moms_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">mean_data</span><span class="p">],</span> <span class="p">[</span><span class="n">var_data</span><span class="p">]])</span>
    <span class="n">mean_sim</span><span class="p">,</span> <span class="n">var_sim</span> <span class="o">=</span> <span class="n">data_moments2</span><span class="p">(</span><span class="n">sim_vals</span><span class="p">)</span>
    <span class="n">mean_model</span> <span class="o">=</span> <span class="n">mean_sim</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
    <span class="n">var_model</span> <span class="o">=</span> <span class="n">var_sim</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
    <span class="n">moms_model</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">mean_model</span><span class="p">],</span> <span class="p">[</span><span class="n">var_model</span><span class="p">]])</span>
    <span class="k">if</span> <span class="n">simple</span><span class="p">:</span>
        <span class="n">err_vec</span> <span class="o">=</span> <span class="n">moms_model</span> <span class="o">-</span> <span class="n">moms_data</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">err_vec</span> <span class="o">=</span> <span class="p">(</span><span class="n">moms_model</span> <span class="o">-</span> <span class="n">moms_data</span><span class="p">)</span> <span class="o">/</span> <span class="n">moms_data</span>

    <span class="k">return</span> <span class="n">err_vec</span>


<span class="k">def</span> <span class="nf">criterion</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    --------------------------------------------------------------------</span>
<span class="sd">    This function computes the SMM weighted sum of squared moment errors</span>
<span class="sd">    criterion function value given parameter values and an estimate of</span>
<span class="sd">    the weighting matrix.</span>
<span class="sd">    --------------------------------------------------------------------</span>
<span class="sd">    INPUTS:</span>
<span class="sd">    params    = (2,) vector, ([mu, sigma])</span>
<span class="sd">    mu        = scalar, mean of the normally distributed random variable</span>
<span class="sd">    sigma     = scalar &gt; 0, standard deviation of the normally</span>
<span class="sd">                distributed random variable</span>
<span class="sd">    args      = length 6 tuple,</span>
<span class="sd">                (xvals, unif_vals, cut_lb, cut_ub, W_hat, simple)</span>
<span class="sd">    xvals     = (N,) vector, values of the truncated normally</span>
<span class="sd">                distributed random variable</span>
<span class="sd">    unif_vals = (N, S) matrix, matrix of draws from U(0,1) distribution.</span>
<span class="sd">                This fixes the seed of the draws for the simulations</span>
<span class="sd">    cut_lb    = scalar or string, =&#39;None&#39; if no lower bound cutoff is</span>
<span class="sd">                given, otherwise is scalar lower bound value of</span>
<span class="sd">                distribution. Values below this cutoff have zero</span>
<span class="sd">                probability</span>
<span class="sd">    cut_ub    = scalar or string, =&#39;None&#39; if no upper bound cutoff is</span>
<span class="sd">                given, otherwise is scalar lower bound value of</span>
<span class="sd">                distribution. Values below this cutoff have zero</span>
<span class="sd">                probability</span>
<span class="sd">    W_hat     = (R, R) matrix, estimate of optimal weighting matrix</span>
<span class="sd">    simple    = Boolean, =True if error vec is simple difference,</span>
<span class="sd">                =False if error vec is percent difference</span>

<span class="sd">    OTHER FUNCTIONS AND FILES CALLED BY THIS FUNCTION:</span>
<span class="sd">        err_vec2()</span>

<span class="sd">    OBJECTS CREATED WITHIN FUNCTION:</span>
<span class="sd">    err        = (2, 1) matrix, column vector of two moment error</span>
<span class="sd">                 functions</span>
<span class="sd">    crit_val   = scalar &gt; 0, GMM criterion function value</span>

<span class="sd">    FILES CREATED BY THIS FUNCTION: None</span>

<span class="sd">    RETURNS: crit_val</span>
<span class="sd">    --------------------------------------------------------------------</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">mu</span><span class="p">,</span> <span class="n">sigma</span> <span class="o">=</span> <span class="n">params</span>
    <span class="n">xvals</span><span class="p">,</span> <span class="n">unif_vals</span><span class="p">,</span> <span class="n">cut_lb</span><span class="p">,</span> <span class="n">cut_ub</span><span class="p">,</span> <span class="n">W_hat</span><span class="p">,</span> <span class="n">simple</span> <span class="o">=</span> <span class="n">args</span>
    <span class="n">err</span> <span class="o">=</span> <span class="n">err_vec2</span><span class="p">(</span><span class="n">xvals</span><span class="p">,</span> <span class="n">unif_vals</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">cut_lb</span><span class="p">,</span> <span class="n">cut_ub</span><span class="p">,</span>
                   <span class="n">simple</span><span class="p">)</span>
    <span class="n">crit_val</span> <span class="o">=</span> <span class="n">err</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">W_hat</span> <span class="o">@</span> <span class="n">err</span>

    <span class="k">return</span> <span class="n">crit_val</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">mu_test</span> <span class="o">=</span> <span class="mi">400</span>
<span class="n">sig_test</span> <span class="o">=</span> <span class="mi">70</span>
<span class="n">cut_lb</span> <span class="o">=</span> <span class="mf">0.0</span>
<span class="n">cut_ub</span> <span class="o">=</span> <span class="mf">450.0</span>
<span class="n">sim_vals</span> <span class="o">=</span> <span class="n">trunc_norm_draws</span><span class="p">(</span><span class="n">unif_vals_2</span><span class="p">,</span> <span class="n">mu_test</span><span class="p">,</span> <span class="n">sig_test</span><span class="p">,</span> <span class="n">cut_lb</span><span class="p">,</span> <span class="n">cut_ub</span><span class="p">)</span>
<span class="n">mean_sim</span><span class="p">,</span> <span class="n">var_sim</span> <span class="o">=</span> <span class="n">data_moments2</span><span class="p">(</span><span class="n">sim_vals</span><span class="p">)</span>
<span class="n">mean_mod</span> <span class="o">=</span> <span class="n">mean_sim</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
<span class="n">var_mod</span> <span class="o">=</span> <span class="n">var_sim</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
<span class="n">err_vec2</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">unif_vals_2</span><span class="p">,</span> <span class="n">mu_test</span><span class="p">,</span> <span class="n">sig_test</span><span class="p">,</span> <span class="n">cut_lb</span><span class="p">,</span> <span class="n">cut_ub</span><span class="p">,</span> <span class="n">simple</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">crit_test</span> <span class="o">=</span> <span class="n">criterion</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">mu_test</span><span class="p">,</span> <span class="n">sig_test</span><span class="p">]),</span> <span class="n">data</span><span class="p">,</span> <span class="n">unif_vals_2</span><span class="p">,</span>
                      <span class="mf">0.0</span><span class="p">,</span> <span class="mf">450.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="kc">False</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Average of mean test scores across simulations is:&quot;</span><span class="p">,</span> <span class="n">mean_mod</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Average variance of test scores across simulations is:&quot;</span><span class="p">,</span> <span class="n">var_mod</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Criterion function value is:&quot;</span><span class="p">,</span> <span class="n">crit_test</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Average of mean test scores across simulations is: 372.0777280048037

Average variance of test scores across simulations is: 2663.8708280174988

Criterion function value is: 0.4429893115777857
</pre></div>
</div>
</div>
</div>
<p>Now we can perform the SMM estimation using SciPy’s minimize function to choose the values of <span class="math notranslate nohighlight">\(\mu\)</span> and <span class="math notranslate nohighlight">\(\sigma\)</span> of the truncated normal distribution that best fit the data by minimizing the crietrion function. Let’s start with the identity matrix as our estimate for the optimal weighting matrix <span class="math notranslate nohighlight">\(W = I\)</span>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">mu_init_1</span> <span class="o">=</span> <span class="mi">300</span>
<span class="n">sig_init_1</span> <span class="o">=</span> <span class="mi">30</span>
<span class="n">params_init_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">mu_init_1</span><span class="p">,</span> <span class="n">sig_init_1</span><span class="p">])</span>
<span class="n">W_hat1_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">smm_args1_1</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">unif_vals_2</span><span class="p">,</span> <span class="n">cut_lb</span><span class="p">,</span> <span class="n">cut_ub</span><span class="p">,</span> <span class="n">W_hat1_1</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
<span class="n">results1_1</span> <span class="o">=</span> <span class="n">opt</span><span class="o">.</span><span class="n">minimize</span><span class="p">(</span><span class="n">criterion</span><span class="p">,</span> <span class="n">params_init_1</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">smm_args1_1</span><span class="p">),</span>
                          <span class="n">method</span><span class="o">=</span><span class="s1">&#39;L-BFGS-B&#39;</span><span class="p">,</span>
                          <span class="n">bounds</span><span class="o">=</span><span class="p">((</span><span class="mf">1e-10</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="p">(</span><span class="mf">1e-10</span><span class="p">,</span> <span class="kc">None</span><span class="p">)))</span>
<span class="n">mu_SMM1_1</span><span class="p">,</span> <span class="n">sig_SMM1_1</span> <span class="o">=</span> <span class="n">results1_1</span><span class="o">.</span><span class="n">x</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;mu_SMM1_1=&#39;</span><span class="p">,</span> <span class="n">mu_SMM1_1</span><span class="p">,</span> <span class="s1">&#39; sig_SMM1_1=&#39;</span><span class="p">,</span> <span class="n">sig_SMM1_1</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>mu_SMM1_1= 612.3371352249138  sig_SMM1_1= 197.26434895262162
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">mean_data</span><span class="p">,</span> <span class="n">var_data</span> <span class="o">=</span> <span class="n">data_moments2</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Data mean of scores =&#39;</span><span class="p">,</span> <span class="n">mean_data</span><span class="p">,</span> <span class="s1">&#39;, Data variance of scores =&#39;</span><span class="p">,</span> <span class="n">var_data</span><span class="p">)</span>
<span class="n">sim_vals_1</span> <span class="o">=</span> <span class="n">trunc_norm_draws</span><span class="p">(</span><span class="n">unif_vals_2</span><span class="p">,</span> <span class="n">mu_SMM1_1</span><span class="p">,</span> <span class="n">sig_SMM1_1</span><span class="p">,</span> <span class="n">cut_lb</span><span class="p">,</span> <span class="n">cut_ub</span><span class="p">)</span>
<span class="n">mean_sim_1</span><span class="p">,</span> <span class="n">var_sim_1</span> <span class="o">=</span> <span class="n">data_moments2</span><span class="p">(</span><span class="n">sim_vals_1</span><span class="p">)</span>
<span class="n">mean_model_1</span> <span class="o">=</span> <span class="n">mean_sim_1</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
<span class="n">var_model_1</span> <span class="o">=</span> <span class="n">var_sim_1</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
<span class="n">err_1</span> <span class="o">=</span> <span class="n">err_vec2</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">unif_vals_2</span><span class="p">,</span> <span class="n">mu_SMM1_1</span><span class="p">,</span> <span class="n">sig_SMM1_1</span><span class="p">,</span> <span class="n">cut_lb</span><span class="p">,</span> <span class="n">cut_ub</span><span class="p">,</span>
                 <span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Model mean 1 =&#39;</span><span class="p">,</span> <span class="n">mean_model_1</span><span class="p">,</span> <span class="s1">&#39;, Model variance 1 =&#39;</span><span class="p">,</span> <span class="n">var_model_1</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Error vector 1 =&#39;</span><span class="p">,</span> <span class="n">err_1</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Results from scipy.opmtimize.minimize:&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">results1_1</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Data mean of scores = 341.90869565217395 , Data variance of scores = 7827.997292398056
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Model mean 1 = 341.6692110494425 , Model variance 1 = 7827.864496338213

Error vector 1 = [-7.00434373e-04 -1.69642445e-05]

Results from scipy.opmtimize.minimize:
  message: CONVERGENCE: NORM_OF_PROJECTED_GRADIENT_&lt;=_PGTOL
  success: True
   status: 0
      fun: 4.908960959342433e-07
        x: [ 6.123e+02  1.973e+02]
      nit: 17
      jac: [-7.436e-07  2.350e-06]
     nfev: 72
     njev: 24
 hess_inv: &lt;2x2 LbfgsInvHessProduct with dtype=float64&gt;
</pre></div>
</div>
</div>
</div>
<p>Let’s plot the PDF implied by these SMM estimates <span class="math notranslate nohighlight">\((\hat{\mu}_{SMM},\hat{\sigma}_{SMM})=(612.337, 197.264)\)</span> against the histogram of the data in <a class="reference internal" href="#figsmm-econ381-smm1"><span class="std std-numref">Figure 5</span></a> below.</p>
<div class="cell tag_remove-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Plot the histogram of the data</span>
<span class="n">count</span><span class="p">,</span> <span class="n">bins</span><span class="p">,</span> <span class="n">ignored</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                <span class="n">edgecolor</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mf">1.2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;data&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Econ 381 scores: 2011-2012&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Total points&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Percent of scores&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">550</span><span class="p">])</span>  <span class="c1"># This gives the xmin and xmax to be plotted&quot;</span>

<span class="c1"># Plot the estimated SMM PDF</span>
<span class="n">dist_pts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">450</span><span class="p">,</span> <span class="mi">500</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">dist_pts</span><span class="p">,</span> <span class="n">trunc_norm_pdf</span><span class="p">(</span><span class="n">dist_pts</span><span class="p">,</span> <span class="n">mu_SMM1_1</span><span class="p">,</span> <span class="n">sig_SMM1_1</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">450.0</span><span class="p">),</span>
         <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;PDF: ($\hat{\mu}_</span><span class="si">{SMM1}</span><span class="s1">$,$\hat{\sigma}_</span><span class="si">{SMM1}</span><span class="s1">$)=(612.34, 197.26)&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;upper left&#39;</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<figure class="align-default" id="figsmm-econ381-smm1">
<a class="reference internal image-reference" href="../_images/Econ381scores_smm1.png"><img alt="../_images/Econ381scores_smm1.png" src="../_images/Econ381scores_smm1.png" style="height: 500px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 5 </span><span class="caption-text">SMM-estimated PDF function and data histogram, 2 moments, identity weighting matrix, Econ 381 scores (2011-2012)</span><a class="headerlink" href="#figsmm-econ381-smm1" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>That looks just like the maximum likelihood estimate from the <a class="reference internal" href="MaxLikelihood.html#chap-maxlikeli"><span class="std std-ref">Maximum Likelihood Estimation</span></a> chapter. <a class="reference internal" href="#figsmm-econ381-crit1"><span class="std std-numref">Figure 6</span></a> below shows what the minimizer is doing. The figure shows the criterion function surface for different of <span class="math notranslate nohighlight">\(\mu\)</span> and <span class="math notranslate nohighlight">\(\sigma\)</span> in the truncated normal distribution. The minimizer is searching for the parameter values that give the lowest criterion function value.</p>
<div class="cell tag_remove-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">mu_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">60</span><span class="p">,</span> <span class="mi">700</span><span class="p">,</span> <span class="mi">90</span><span class="p">)</span>
<span class="n">sig_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">250</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="n">crit_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">90</span><span class="p">,</span> <span class="mi">100</span><span class="p">))</span>
<span class="n">crit_args</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">unif_vals_2</span><span class="p">,</span> <span class="n">cut_lb</span><span class="p">,</span> <span class="n">cut_ub</span><span class="p">,</span> <span class="n">W_hat1_1</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
<span class="k">for</span> <span class="n">mu_ind</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">90</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">sig_ind</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">100</span><span class="p">):</span>
        <span class="n">crit_params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">mu_vals</span><span class="p">[</span><span class="n">mu_ind</span><span class="p">],</span> <span class="n">sig_vals</span><span class="p">[</span><span class="n">sig_ind</span><span class="p">]])</span>
        <span class="n">crit_vals</span><span class="p">[</span><span class="n">mu_ind</span><span class="p">,</span> <span class="n">sig_ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">criterion</span><span class="p">(</span><span class="n">crit_params</span><span class="p">,</span> <span class="o">*</span><span class="n">crit_args</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

<span class="n">mu_mesh</span><span class="p">,</span> <span class="n">sig_mesh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">mu_vals</span><span class="p">,</span> <span class="n">sig_vals</span><span class="p">)</span>

<span class="n">crit_SMM1_1</span> <span class="o">=</span> <span class="n">criterion</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">mu_SMM1_1</span><span class="p">,</span> <span class="n">sig_SMM1_1</span><span class="p">]),</span> <span class="o">*</span><span class="n">crit_args</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">subplot_kw</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;projection&quot;</span><span class="p">:</span> <span class="s2">&quot;3d&quot;</span><span class="p">})</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot_surface</span><span class="p">(</span><span class="n">mu_mesh</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">sig_mesh</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">crit_vals</span><span class="p">,</span> <span class="n">rstride</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span>
                <span class="n">cstride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap1</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.9</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">mu_SMM1_1</span><span class="p">,</span> <span class="n">sig_SMM1_1</span><span class="p">,</span> <span class="n">crit_SMM1_1</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;o&#39;</span><span class="p">,</span>
           <span class="n">s</span><span class="o">=</span><span class="mi">18</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;SMM1 estimate&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">view_init</span><span class="p">(</span><span class="n">elev</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span> <span class="n">azim</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">roll</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Criterion function for values of mu and sigma&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$\mu$&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$\sigma$&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_zlabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;Crit. func.&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>

<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<figure class="align-default" id="figsmm-econ381-crit1">
<a class="reference internal image-reference" href="../_images/Econ381_crit1.png"><img alt="../_images/Econ381_crit1.png" src="../_images/Econ381_crit1.png" style="height: 500px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 6 </span><span class="caption-text">Criterion function surface for values of <span class="math notranslate nohighlight">\(\mu\)</span> and <span class="math notranslate nohighlight">\(\sigma\)</span> for SMM estimation of truncated normal with two moments and identity weighting matrix (SMM estimate shown as red dot)</span><a class="headerlink" href="#figsmm-econ381-crit1" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>Let’s compute the SMM estimator for the variance-covariance matrix <span class="math notranslate nohighlight">\(\hat{\Sigma}_{SMM}\)</span> of our SMM estimates <span class="math notranslate nohighlight">\(\hat{\theta}_{SMM}\)</span> using the equation in Section <a class="reference internal" href="#secsmm-varcovtheta"><span class="std std-ref">Variance-Covariance Estimator of \hat{\theta}</span></a> based on the Jacobian <span class="math notranslate nohighlight">\(d(\tilde{x},x|\hat{\theta}_{SMM})\)</span> of the moment error vector <span class="math notranslate nohighlight">\(e(\tilde{x},x|\hat{\theta}_{SMM})\)</span> from the criterion function at the estimated (optimal) parameter values <span class="math notranslate nohighlight">\(\hat{\theta}_{SMM}\)</span>. We first write a function that computes the Jacobian matrix <span class="math notranslate nohighlight">\(d(x|\hat{\theta}_{SMM})\)</span>, which has shape <span class="math notranslate nohighlight">\(2\times 2\)</span> in this case with two moments <span class="math notranslate nohighlight">\(R=2\)</span>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">Jac_err2</span><span class="p">(</span><span class="n">data_vals</span><span class="p">,</span> <span class="n">unif_vals</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">cut_lb</span><span class="p">,</span> <span class="n">cut_ub</span><span class="p">,</span> <span class="n">simple</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    This function computes the Jacobian matrix of partial derivatives of the</span>
<span class="sd">    R x 1 moment error vector e(x|theta) with respect to the K parameters</span>
<span class="sd">    theta_i in the K x 1 parameter vector theta. The resulting matrix is R x K</span>
<span class="sd">    Jacobian.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">Jac_err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
    <span class="n">h_mu</span> <span class="o">=</span> <span class="mf">1e-4</span> <span class="o">*</span> <span class="n">mu</span>
    <span class="n">h_sig</span> <span class="o">=</span> <span class="mf">1e-4</span> <span class="o">*</span> <span class="n">sigma</span>
    <span class="n">Jac_err</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
        <span class="p">(</span><span class="n">err_vec2</span><span class="p">(</span><span class="n">xvals</span><span class="p">,</span> <span class="n">unif_vals</span><span class="p">,</span> <span class="n">mu</span> <span class="o">+</span> <span class="n">h_mu</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">cut_lb</span><span class="p">,</span> <span class="n">cut_ub</span><span class="p">,</span> <span class="n">simple</span><span class="p">)</span> <span class="o">-</span>
         <span class="n">err_vec2</span><span class="p">(</span><span class="n">xvals</span><span class="p">,</span> <span class="n">unif_vals</span><span class="p">,</span> <span class="n">mu</span> <span class="o">-</span> <span class="n">h_mu</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">cut_lb</span><span class="p">,</span> <span class="n">cut_ub</span><span class="p">,</span> <span class="n">simple</span><span class="p">))</span> <span class="o">/</span>
        <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">h_mu</span><span class="p">)</span>
    <span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="n">Jac_err</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
        <span class="p">(</span><span class="n">err_vec2</span><span class="p">(</span><span class="n">xvals</span><span class="p">,</span> <span class="n">unif_vals</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">sigma</span> <span class="o">+</span> <span class="n">h_sig</span><span class="p">,</span> <span class="n">cut_lb</span><span class="p">,</span> <span class="n">cut_ub</span><span class="p">,</span> <span class="n">simple</span><span class="p">)</span> <span class="o">-</span>
         <span class="n">err_vec2</span><span class="p">(</span><span class="n">xvals</span><span class="p">,</span> <span class="n">unif_vals</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">sigma</span> <span class="o">-</span> <span class="n">h_sig</span><span class="p">,</span> <span class="n">cut_lb</span><span class="p">,</span> <span class="n">cut_ub</span><span class="p">,</span> <span class="n">simple</span><span class="p">))</span> <span class="o">/</span>
        <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">h_sig</span><span class="p">)</span>
    <span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">Jac_err</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">S</span> <span class="o">=</span> <span class="n">unif_vals_2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="n">d_err2</span> <span class="o">=</span> <span class="n">Jac_err2</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">unif_vals_2</span><span class="p">,</span> <span class="n">mu_SMM1_1</span><span class="p">,</span> <span class="n">sig_SMM1_1</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">450.0</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Jacobian matrix of derivatives of moment error functions is:&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">d_err2</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Weighting matrix W is:&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">W_hat1_1</span><span class="p">)</span>
<span class="n">SigHat2</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">S</span><span class="p">)</span> <span class="o">*</span> <span class="n">lin</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">d_err2</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">W_hat1_1</span> <span class="o">@</span> <span class="n">d_err2</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Variance-covariance matrix of estimated parameter vector is:&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">SigHat2</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Std. err. mu_hat=&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">SigHat2</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Std. err. sig_hat=&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">SigHat2</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Jacobian matrix of derivatives of moment error functions is:
[[ 0.00089749 -0.00290433]
 [-0.00114132  0.00445698]]

Weighting matrix W is:
[[1. 0.]
 [0. 1.]]

Variance-covariance matrix of estimated parameter vector is:
[[602535.18442996 163802.17330123]
 [163802.17330123  44883.79092131]]

Std. err. mu_hat= 776.23139876583
Std. err. sig_hat= 211.85794986573154
</pre></div>
</div>
</div>
</div>
<p>This SMM estimation methodology of estimating <span class="math notranslate nohighlight">\(\mu\)</span> and <span class="math notranslate nohighlight">\(\sigma\)</span> from the truncated normal distribution to fit the distribution of Econ 381 test scores using two moments from the data and using the identity matrix as the optimal weighting matrix is not very precise. The standard errors for the estimates of <span class="math notranslate nohighlight">\(\hat{mu}\)</span> and <span class="math notranslate nohighlight">\(\hat{sigma}\)</span> are bigger than their values.</p>
<p>In the next section, we see if we can get more accurate estimates (lower criterion function values) of <span class="math notranslate nohighlight">\(\hat{mu}\)</span> and <span class="math notranslate nohighlight">\(\hat{sigma}\)</span> with more precise standard errors by using the two-step optimal weighting matrix described in Section <a class="reference internal" href="#secsmm-w-2step"><span class="std std-ref">Two-step variance-covariance estimator of W</span></a>.</p>
</section>
<section id="two-moments-two-step-optimal-weighting-matrix">
<span id="secsmm-codeexmp-macrtest-2m2st"></span><h4>Two moments, two-step optimal weighting matrix<a class="headerlink" href="#two-moments-two-step-optimal-weighting-matrix" title="Permalink to this heading">#</a></h4>
<p>Similar to the maximum likelihood estimation problem in Chapter <a class="reference internal" href="MaxLikelihood.html#chap-maxlikeli"><span class="std std-ref">Maximum Likelihood Estimation</span></a>, it looks like the minimum value of the criterion function shown in <a class="reference internal" href="#figsmm-econ381-crit1"><span class="std std-numref">Figure 6</span></a> is roughly equal for a specific portion increase of <span class="math notranslate nohighlight">\(\mu\)</span> and <span class="math notranslate nohighlight">\(\sigma\)</span> together. That is, the estimation problem with these two moments probably has a correspondence of values of <span class="math notranslate nohighlight">\(\mu\)</span> and <span class="math notranslate nohighlight">\(\sigma\)</span> that give roughly the same minimum criterion function value. This issue has two possible solutions.</p>
<ol class="arabic simple">
<li><p>Maybe we need the two-step variance covariance estimator to calculate a “more” optimal weighting matrix <span class="math notranslate nohighlight">\(W\)</span>.</p></li>
<li><p>Maybe our two moments aren’t very good moments for fitting the data.</p></li>
</ol>
<p>Let’s first try the two-step weighting matrix.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_Err_mat2</span><span class="p">(</span><span class="n">pts</span><span class="p">,</span> <span class="n">unif_vals</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">cut_lb</span><span class="p">,</span> <span class="n">cut_ub</span><span class="p">,</span> <span class="n">simple</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    --------------------------------------------------------------------</span>
<span class="sd">    This function computes the R x S matrix of errors from each</span>
<span class="sd">    simulated moment for each moment error. In this function, we have</span>
<span class="sd">    hard coded R = 2.</span>
<span class="sd">    --------------------------------------------------------------------</span>
<span class="sd">    INPUTS:</span>
<span class="sd">    xvals     = (N,) vector, test scores data</span>
<span class="sd">    unif_vals = (N, S) matrix, uniform random variables that generate</span>
<span class="sd">                the N observations of simulated data for S simulations</span>
<span class="sd">    mu        = scalar, mean of the normally distributed random variable</span>
<span class="sd">    sigma     = scalar &gt; 0, standard deviation of the normally</span>
<span class="sd">                distributed random variable</span>
<span class="sd">    cut_lb    = scalar or string, =&#39;None&#39; if no cutoff is given,</span>
<span class="sd">                otherwise is scalar lower bound value of distribution.</span>
<span class="sd">                Values below this value have zero probability</span>
<span class="sd">    cut_ub    = scalar or string, =&#39;None&#39; if no cutoff is given,</span>
<span class="sd">                otherwise is scalar upper bound value of distribution.</span>
<span class="sd">                Values above this value have zero probability</span>
<span class="sd">    simple    = boolean, =True if errors are simple difference, =False</span>
<span class="sd">                if errors are percent deviation from data moments</span>

<span class="sd">    OTHER FUNCTIONS AND FILES CALLED BY THIS FUNCTION:</span>
<span class="sd">        model_moments()</span>

<span class="sd">    OBJECTS CREATED WITHIN FUNCTION:</span>
<span class="sd">    R          = integer = 2, hard coded number of moments</span>
<span class="sd">    S          = integer &gt;= R, number of simulated datasets</span>
<span class="sd">    Err_mat    = (R, S) matrix, error by moment and simulated data</span>
<span class="sd">    mean_model = scalar, mean value from model</span>
<span class="sd">    var_model  = scalar &gt; 0, variance from model</span>

<span class="sd">    FILES CREATED BY THIS FUNCTION: None</span>

<span class="sd">    RETURNS: Err_mat</span>
<span class="sd">    --------------------------------------------------------------------</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">R</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">S</span> <span class="o">=</span> <span class="n">unif_vals</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">Err_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">R</span><span class="p">,</span> <span class="n">S</span><span class="p">))</span>
    <span class="n">mean_data</span><span class="p">,</span> <span class="n">var_data</span> <span class="o">=</span> <span class="n">data_moments2</span><span class="p">(</span><span class="n">pts</span><span class="p">)</span>
    <span class="n">sim_vals</span> <span class="o">=</span> <span class="n">trunc_norm_draws</span><span class="p">(</span><span class="n">unif_vals</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">cut_lb</span><span class="p">,</span> <span class="n">cut_ub</span><span class="p">)</span>
    <span class="n">mean_model</span><span class="p">,</span> <span class="n">var_model</span> <span class="o">=</span> <span class="n">data_moments2</span><span class="p">(</span><span class="n">sim_vals</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">simple</span><span class="p">:</span>
        <span class="n">Err_mat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">mean_model</span> <span class="o">-</span> <span class="n">mean_data</span>
        <span class="n">Err_mat</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">var_model</span> <span class="o">-</span> <span class="n">var_data</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">Err_mat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">(</span><span class="n">mean_model</span> <span class="o">-</span> <span class="n">mean_data</span><span class="p">)</span> <span class="o">/</span> <span class="n">mean_data</span>
        <span class="n">Err_mat</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">(</span><span class="n">var_model</span> <span class="o">-</span> <span class="n">var_data</span><span class="p">)</span> <span class="o">/</span> <span class="n">var_data</span>

    <span class="k">return</span> <span class="n">Err_mat</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">Err_mat2</span> <span class="o">=</span> <span class="n">get_Err_mat2</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">unif_vals_2</span><span class="p">,</span> <span class="n">mu_SMM1_1</span><span class="p">,</span> <span class="n">sig_SMM1_1</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">450.0</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
<span class="n">VCV2</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">unif_vals_2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">Err_mat2</span> <span class="o">@</span> <span class="n">Err_mat2</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;2nd stage est. of var-cov matrix of moment error vec across sims:&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">VCV2</span><span class="p">)</span>
<span class="n">W_hat2_1</span> <span class="o">=</span> <span class="n">lin</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">VCV2</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;2nd state est. of optimal weighting matrix:&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">W_hat2_1</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>2nd stage est. of var-cov matrix of moment error vec across sims:
[[ 0.00033411 -0.00142289]
 [-0.00142289  0.01592879]]

2nd state est. of optimal weighting matrix:
[[4830.88530228  431.53378728]
 [ 431.53378728  101.32749623]]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">params_init2_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">mu_SMM1_1</span><span class="p">,</span> <span class="n">sig_SMM1_1</span><span class="p">])</span>
<span class="n">smm_args2_1</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">unif_vals_2</span><span class="p">,</span> <span class="n">cut_lb</span><span class="p">,</span> <span class="n">cut_ub</span><span class="p">,</span> <span class="n">W_hat2_1</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
<span class="n">results2_1</span> <span class="o">=</span> <span class="n">opt</span><span class="o">.</span><span class="n">minimize</span><span class="p">(</span><span class="n">criterion</span><span class="p">,</span> <span class="n">params_init2_1</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">smm_args2_1</span><span class="p">),</span>
                         <span class="n">method</span><span class="o">=</span><span class="s1">&#39;L-BFGS-B&#39;</span><span class="p">,</span>
                         <span class="n">bounds</span><span class="o">=</span><span class="p">((</span><span class="mf">1e-10</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="p">(</span><span class="mf">1e-10</span><span class="p">,</span> <span class="kc">None</span><span class="p">)))</span>
<span class="n">mu_SMM2_1</span><span class="p">,</span> <span class="n">sig_SMM2_1</span> <span class="o">=</span> <span class="n">results2_1</span><span class="o">.</span><span class="n">x</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;mu_SMM2_1=&#39;</span><span class="p">,</span> <span class="n">mu_SMM2_1</span><span class="p">,</span> <span class="s1">&#39; sig_SMM2_1=&#39;</span><span class="p">,</span> <span class="n">sig_SMM2_1</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>mu_SMM2_1= 619.4303074248937  sig_SMM2_1= 199.0747813692372
</pre></div>
</div>
</div>
</div>
<p>Look at how much smaller (more efficient) the estimated standard errors are in this case with the two-step optimal weighting matrix <span class="math notranslate nohighlight">\(\hat{W}_{2step}\)</span>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">d_err2_2</span> <span class="o">=</span> <span class="n">Jac_err2</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">unif_vals_2</span><span class="p">,</span> <span class="n">mu_SMM2_1</span><span class="p">,</span> <span class="n">sig_SMM2_1</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">450.0</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Jacobian matrix of derivatives of moment error functions is:&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">d_err2_2</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Weighting matrix W is:&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">W_hat2_1</span><span class="p">)</span>
<span class="n">SigHat2_2</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">S</span><span class="p">)</span> <span class="o">*</span> <span class="n">lin</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">d_err2_2</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">W_hat2_1</span> <span class="o">@</span> <span class="n">d_err2_2</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Variance-covariance matrix of estimated parameter vector is:&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">SigHat2_2</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Std. err. mu_hat=&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">SigHat2_2</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Std. err. sig_hat=&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">SigHat2_2</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Jacobian matrix of derivatives of moment error functions is:
[[ 0.00088129 -0.00288863]
 [-0.0011259   0.00443426]]

Weighting matrix W is:
[[4830.88530228  431.53378728]
 [ 431.53378728  101.32749623]]

Variance-covariance matrix of estimated parameter vector is:
[[2397.38054356  745.29670501]
 [ 745.29670501  232.01757158]]

Std. err. mu_hat= 48.963052841479445
Std. err. sig_hat= 15.232123016118733
</pre></div>
</div>
</div>
</div>
</section>
<section id="four-moments-identity-matrix-weighting-matrix">
<span id="secsmm-codeexmp-macrtest-4mi"></span><h4>Four moments, identity matrix weighting matrix<a class="headerlink" href="#four-moments-identity-matrix-weighting-matrix" title="Permalink to this heading">#</a></h4>
<p>Using a better weighting matrix didn’t improve our estimates or fit very much—the estimates of <span class="math notranslate nohighlight">\(\hat{mu}\)</span> and <span class="math notranslate nohighlight">\(\hat{\sigma}\)</span> and the corresponding minimum criterion function value. But it did improve our standard errors. But even with the optimal weighting matrix, our standard errors still look pretty big. This might mean that we did not choose good moments for fitting the data. Let’s try some different moments. How about four moments to match.</p>
<ol class="arabic simple">
<li><p>The percent of observations greater than 430 (between 430 and 450)</p></li>
<li><p>The percent of observations between 320 and 430</p></li>
<li><p>The percent of observations between 220 and 320</p></li>
<li><p>The percent of observations less than 220 (between 0 and 220)</p></li>
</ol>
<p>This means we are using four moments <span class="math notranslate nohighlight">\(R=4\)</span> to identify two paramters <span class="math notranslate nohighlight">\(\mu\)</span> and <span class="math notranslate nohighlight">\(\sigma\)</span> (<span class="math notranslate nohighlight">\(K=2\)</span>). This problem is now overidentified (<span class="math notranslate nohighlight">\(R&gt;K\)</span>). This is often a desired approach for SMM estimation.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">data_moments4</span><span class="p">(</span><span class="n">xvals</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    --------------------------------------------------------------------</span>
<span class="sd">    This function computes the four data moments for SMM</span>
<span class="sd">    (binpct_1, binpct_2, binpct_3, binpct_4) from both the actual data</span>
<span class="sd">    and from the simulated data.</span>
<span class="sd">    --------------------------------------------------------------------</span>
<span class="sd">    INPUTS:</span>
<span class="sd">    xvals = (N, S) matrix, (N,) vector, or scalar in (cut_lb, cut_ub),</span>
<span class="sd">            test scores data, either real world or simulated. Real world</span>
<span class="sd">            data will come in the form (N,). Simulated data comes in the</span>
<span class="sd">            form (N,) or (N, S).</span>

<span class="sd">    OTHER FUNCTIONS AND FILES CALLED BY THIS FUNCTION: None</span>

<span class="sd">    OBJECTS CREATED WITHIN FUNCTION:</span>
<span class="sd">    bpct_1 = scalar in [0, 1] or (S,) vector, percent of observations</span>
<span class="sd">             0 &lt;= x &lt; 220</span>
<span class="sd">    bpct_2 = scalar in [0, 1] or (S,) vector, percent of observations</span>
<span class="sd">             220 &lt;= x &lt; 320</span>
<span class="sd">    bpct_3 = scalar in [0, 1] or (S,) vector, percent of observations</span>
<span class="sd">             320 &lt;= x &lt; 430</span>
<span class="sd">    bpct_4 = scalar in [0, 1] or (S,) vector, percent of observations</span>
<span class="sd">             430 &lt;= x &lt;= 450</span>

<span class="sd">    FILES CREATED BY THIS FUNCTION: None</span>

<span class="sd">    RETURNS: bpct_1, bpct_2, bpct_3, bpct_4</span>
<span class="sd">    --------------------------------------------------------------------</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">xvals</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">bpct_1</span> <span class="o">=</span> <span class="p">(</span><span class="n">xvals</span> <span class="o">&lt;</span> <span class="mi">220</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="n">xvals</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">bpct_2</span> <span class="o">=</span> <span class="p">((</span><span class="n">xvals</span> <span class="o">&gt;=</span><span class="mi">220</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">xvals</span> <span class="o">&lt;</span> <span class="mi">320</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="n">xvals</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">bpct_3</span> <span class="o">=</span> <span class="p">((</span><span class="n">xvals</span> <span class="o">&gt;=</span><span class="mi">320</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">xvals</span> <span class="o">&lt;</span> <span class="mi">430</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="n">xvals</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">bpct_4</span> <span class="o">=</span> <span class="p">(</span><span class="n">xvals</span> <span class="o">&gt;=</span> <span class="mi">430</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="n">xvals</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">xvals</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">bpct_1</span> <span class="o">=</span> <span class="p">(</span><span class="n">xvals</span> <span class="o">&lt;</span> <span class="mi">220</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="n">xvals</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">bpct_2</span> <span class="o">=</span> <span class="p">(((</span><span class="n">xvals</span> <span class="o">&gt;=</span><span class="mi">220</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">xvals</span> <span class="o">&lt;</span> <span class="mi">320</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span>
                    <span class="n">xvals</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">bpct_3</span> <span class="o">=</span> <span class="p">(((</span><span class="n">xvals</span> <span class="o">&gt;=</span><span class="mi">320</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">xvals</span> <span class="o">&lt;</span> <span class="mi">430</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span>
                    <span class="n">xvals</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">bpct_4</span> <span class="o">=</span> <span class="p">(</span><span class="n">xvals</span> <span class="o">&gt;=</span> <span class="mi">430</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="n">xvals</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">bpct_1</span><span class="p">,</span> <span class="n">bpct_2</span><span class="p">,</span> <span class="n">bpct_3</span><span class="p">,</span> <span class="n">bpct_4</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">err_vec4</span><span class="p">(</span><span class="n">data_vals</span><span class="p">,</span> <span class="n">unif_vals</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">cut_lb</span><span class="p">,</span> <span class="n">cut_ub</span><span class="p">,</span> <span class="n">simple</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    --------------------------------------------------------------------</span>
<span class="sd">    This function computes the vector of moment errors (in percent</span>
<span class="sd">    deviation from the data moment vector) for SMM.</span>
<span class="sd">    --------------------------------------------------------------------</span>
<span class="sd">    INPUTS:</span>
<span class="sd">    data_vals = (N,) vector, test scores data</span>
<span class="sd">    unif_vals = (N, S) matrix, uniform values that generate S</span>
<span class="sd">                simulations of N observations</span>
<span class="sd">    mu        = scalar, mean of the nontruncated normal distribution</span>
<span class="sd">                from which the truncated normal is derived</span>
<span class="sd">    sigma     = scalar &gt; 0, standard deviation of the nontruncated</span>
<span class="sd">                normal distribution from which the truncated normal is</span>
<span class="sd">                derived</span>
<span class="sd">    cut_lb    = scalar or string, =&#39;None&#39; if no lower bound cutoff is</span>
<span class="sd">                given, otherwise is scalar lower bound value of</span>
<span class="sd">                distribution. Values below this cutoff have zero</span>
<span class="sd">                probability</span>
<span class="sd">    cut_ub    = scalar or string, =&#39;None&#39; if no upper bound cutoff is</span>
<span class="sd">                given, otherwise is scalar lower bound value of</span>
<span class="sd">                distribution. Values below this cutoff have zero</span>
<span class="sd">                probability</span>
<span class="sd">    simple    = boolean, =True if errors are simple difference, =False</span>
<span class="sd">                if errors are percent deviation from data moments</span>

<span class="sd">    OTHER FUNCTIONS AND FILES CALLED BY THIS FUNCTION:</span>
<span class="sd">        data_moments4()</span>

<span class="sd">    OBJECTS CREATED WITHIN FUNCTION:</span>
<span class="sd">    mean_data  = scalar, mean value of data</span>
<span class="sd">    var_data   = scalar &gt; 0, variance of data</span>
<span class="sd">    moms_data  = (4, 1) matrix, column vector of two data moments</span>
<span class="sd">    mean_model = scalar, mean value from model</span>
<span class="sd">    var_model  = scalar &gt; 0, variance from model</span>
<span class="sd">    moms_model = (2, 1) matrix, column vector of two model moments</span>
<span class="sd">    err_vec    = (2, 1) matrix, column vector of two moment error</span>
<span class="sd">                 functions</span>

<span class="sd">    FILES CREATED BY THIS FUNCTION: None</span>

<span class="sd">    RETURNS: err_vec</span>
<span class="sd">    --------------------------------------------------------------------</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">sim_vals</span> <span class="o">=</span> <span class="n">trunc_norm_draws</span><span class="p">(</span><span class="n">unif_vals</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">cut_lb</span><span class="p">,</span> <span class="n">cut_ub</span><span class="p">)</span>
    <span class="n">bpct_1_dat</span><span class="p">,</span> <span class="n">bpct_2_dat</span><span class="p">,</span> <span class="n">bpct_3_dat</span><span class="p">,</span> <span class="n">bpct_4_dat</span> <span class="o">=</span> \
        <span class="n">data_moments4</span><span class="p">(</span><span class="n">data_vals</span><span class="p">)</span>
    <span class="n">moms_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">bpct_1_dat</span><span class="p">],</span> <span class="p">[</span><span class="n">bpct_2_dat</span><span class="p">],</span> <span class="p">[</span><span class="n">bpct_3_dat</span><span class="p">],</span>
                          <span class="p">[</span><span class="n">bpct_4_dat</span><span class="p">]])</span>
    <span class="n">bpct_1_sim</span><span class="p">,</span> <span class="n">bpct_2_sim</span><span class="p">,</span> <span class="n">bpct_3_sim</span><span class="p">,</span> <span class="n">bpct_4_sim</span> <span class="o">=</span> \
        <span class="n">data_moments4</span><span class="p">(</span><span class="n">sim_vals</span><span class="p">)</span>
    <span class="n">bpct_1_mod</span> <span class="o">=</span> <span class="n">bpct_1_sim</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
    <span class="n">bpct_2_mod</span> <span class="o">=</span> <span class="n">bpct_2_sim</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
    <span class="n">bpct_3_mod</span> <span class="o">=</span> <span class="n">bpct_3_sim</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
    <span class="n">bpct_4_mod</span> <span class="o">=</span> <span class="n">bpct_4_sim</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
    <span class="n">moms_model</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">bpct_1_mod</span><span class="p">],</span> <span class="p">[</span><span class="n">bpct_2_mod</span><span class="p">],</span> <span class="p">[</span><span class="n">bpct_3_mod</span><span class="p">],</span>
                          <span class="p">[</span><span class="n">bpct_4_mod</span><span class="p">]])</span>
    <span class="k">if</span> <span class="n">simple</span><span class="p">:</span>
        <span class="n">err_vec</span> <span class="o">=</span> <span class="n">moms_model</span> <span class="o">-</span> <span class="n">moms_data</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">err_vec</span> <span class="o">=</span> <span class="p">(</span><span class="n">moms_model</span> <span class="o">-</span> <span class="n">moms_data</span><span class="p">)</span> <span class="o">/</span> <span class="n">moms_data</span>

    <span class="k">return</span> <span class="n">err_vec</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">criterion4</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    --------------------------------------------------------------------</span>
<span class="sd">    This function computes the SMM weighted sum of squared moment errors</span>
<span class="sd">    criterion function value given parameter values and an estimate of</span>
<span class="sd">    the weighting matrix.</span>
<span class="sd">    --------------------------------------------------------------------</span>
<span class="sd">    INPUTS:</span>
<span class="sd">    params    = (2,) vector, ([mu, sigma])</span>
<span class="sd">    mu        = scalar, mean of the normally distributed random variable</span>
<span class="sd">    sigma     = scalar &gt; 0, standard deviation of the normally</span>
<span class="sd">                distributed random variable</span>
<span class="sd">    args      = length 5 tuple,</span>
<span class="sd">                (xvals, unif_vals, cut_lb, cut_ub, W_hat)</span>
<span class="sd">    xvals     = (N,) vector, values of the truncated normally</span>
<span class="sd">                distributed random variable</span>
<span class="sd">    unif_vals = (N, S) matrix, matrix of draws from U(0,1) distribution.</span>
<span class="sd">                This fixes the seed of the draws for the simulations</span>
<span class="sd">    cut_lb    = scalar or string, =&#39;None&#39; if no lower bound cutoff is</span>
<span class="sd">                given, otherwise is scalar lower bound value of</span>
<span class="sd">                distribution. Values below this cutoff have zero</span>
<span class="sd">                probability</span>
<span class="sd">    cut_ub    = scalar or string, =&#39;None&#39; if no upper bound cutoff is</span>
<span class="sd">                given, otherwise is scalar lower bound value of</span>
<span class="sd">                distribution. Values below this cutoff have zero</span>
<span class="sd">                probability</span>
<span class="sd">    W_hat     = (R, R) matrix, estimate of optimal weighting matrix</span>

<span class="sd">    OTHER FUNCTIONS AND FILES CALLED BY THIS FUNCTION:</span>
<span class="sd">        norm_pdf()</span>

<span class="sd">    OBJECTS CREATED WITHIN FUNCTION:</span>
<span class="sd">    err        = (2, 1) matrix, column vector of two moment error</span>
<span class="sd">                 functions</span>
<span class="sd">    crit_val   = scalar &gt; 0, GMM criterion function value</span>

<span class="sd">    FILES CREATED BY THIS FUNCTION: None</span>

<span class="sd">    RETURNS: crit_val</span>
<span class="sd">    --------------------------------------------------------------------</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">mu</span><span class="p">,</span> <span class="n">sigma</span> <span class="o">=</span> <span class="n">params</span>
    <span class="n">xvals</span><span class="p">,</span> <span class="n">unif_vals</span><span class="p">,</span> <span class="n">cut_lb</span><span class="p">,</span> <span class="n">cut_ub</span><span class="p">,</span> <span class="n">W_hat</span> <span class="o">=</span> <span class="n">args</span>

    <span class="c1"># # These next two lines diagnose a problems in the next frame</span>
    <span class="c1"># print(&#39;mu=&#39;, mu)</span>
    <span class="c1"># print(&#39;sigma&#39;, sigma)</span>

    <span class="n">err</span> <span class="o">=</span> <span class="n">err_vec4</span><span class="p">(</span><span class="n">xvals</span><span class="p">,</span> <span class="n">unif_vals</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">cut_lb</span><span class="p">,</span> <span class="n">cut_ub</span><span class="p">,</span>
                   <span class="n">simple</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">crit_val</span> <span class="o">=</span> <span class="n">err</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">W_hat</span> <span class="o">@</span> <span class="n">err</span>

    <span class="k">return</span> <span class="n">crit_val</span>
</pre></div>
</div>
</div>
</div>
<p>Now we will execute the SMM minimization problem, but a strange issue will arise. And the issue has to do with the minimizer.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">mu_init4_1</span> <span class="o">=</span> <span class="mi">300</span>
<span class="n">sig_init4_1</span> <span class="o">=</span> <span class="mi">30</span>
<span class="n">params_init4_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">mu_init4_1</span><span class="p">,</span> <span class="n">sig_init4_1</span><span class="p">])</span>
<span class="n">W_hat4_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="n">smm_args4_1</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">unif_vals_2</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mi">450</span><span class="p">,</span> <span class="n">W_hat4_1</span><span class="p">)</span>
<span class="n">results4_1</span> <span class="o">=</span> <span class="n">opt</span><span class="o">.</span><span class="n">minimize</span><span class="p">(</span><span class="n">criterion4</span><span class="p">,</span> <span class="n">params_init4_1</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">smm_args4_1</span><span class="p">),</span>
                          <span class="n">method</span><span class="o">=</span><span class="s1">&#39;L-BFGS-B&#39;</span><span class="p">,</span>
                          <span class="n">bounds</span><span class="o">=</span><span class="p">((</span><span class="mf">1e-10</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="p">(</span><span class="mf">1e-10</span><span class="p">,</span> <span class="kc">None</span><span class="p">)))</span>
<span class="n">mu_SMM4_1</span><span class="p">,</span> <span class="n">sig_SMM4_1</span> <span class="o">=</span> <span class="n">results4_1</span><span class="o">.</span><span class="n">x</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;mu_SMM4_1=&#39;</span><span class="p">,</span> <span class="n">mu_SMM4_1</span><span class="p">,</span> <span class="s1">&#39; sig_SMM4_1&#39;</span><span class="p">,</span> <span class="n">sig_SMM4_1</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">results4_1</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>mu_SMM4_1= 300.0  sig_SMM4_1 30.0
  message: CONVERGENCE: NORM_OF_PROJECTED_GRADIENT_&lt;=_PGTOL
  success: True
   status: 0
      fun: 12.836206045344852
        x: [ 3.000e+02  3.000e+01]
      nit: 0
      jac: [ 0.000e+00  0.000e+00]
     nfev: 3
     njev: 1
 hess_inv: &lt;2x2 LbfgsInvHessProduct with dtype=float64&gt;
</pre></div>
</div>
</div>
</div>
<p>Note that the optimization problem only did three function evaluations, and it decided that the parameter values that minimized the criterion function are the initial values. Something is wrong.</p>
<p>To see what is happening in the minimizer, let’s insert a line in the <code class="docutils literal notranslate"><span class="pre">criterion4()</span></code> function that prints out the values of <span class="math notranslate nohighlight">\(\mu\)</span> and <span class="math notranslate nohighlight">\(\sigma\)</span> for each function evaluation in the minimizer as well as the error vector associated with each guess of <span class="math notranslate nohighlight">\(\mu\)</span> and <span class="math notranslate nohighlight">\(\sigma\)</span>.</p>
<p>Note that the three function evaluations are for guesses of <span class="math notranslate nohighlight">\(\mu\)</span> and <span class="math notranslate nohighlight">\(\sigma\)</span> of:</p>
<ul class="simple">
<li><p>Guess 1: <span class="math notranslate nohighlight">\(\mu\)</span>=<code class="docutils literal notranslate"><span class="pre">mu_init</span></code> and <span class="math notranslate nohighlight">\(\sigma\)</span>=<code class="docutils literal notranslate"><span class="pre">sig_init</span></code></p></li>
<li><p>Guess 2: <span class="math notranslate nohighlight">\(\mu\)</span>=<code class="docutils literal notranslate"><span class="pre">mu_init</span> <span class="pre">+</span> <span class="pre">0.00000001</span></code> and <span class="math notranslate nohighlight">\(\sigma\)</span>=<code class="docutils literal notranslate"><span class="pre">sig_init</span></code></p></li>
<li><p>Guess 3: <span class="math notranslate nohighlight">\(\mu\)</span>=<code class="docutils literal notranslate"><span class="pre">mu_init</span></code> and <span class="math notranslate nohighlight">\(\sigma\)</span>=<code class="docutils literal notranslate"><span class="pre">sig_init</span> <span class="pre">+</span> <span class="pre">0.00000001</span></code></p></li>
</ul>
<p>This is the <code class="docutils literal notranslate"><span class="pre">L-BFGS-B</span></code> method’s way of computing the Jacobian or slope (gradient) matrix of the criterion function by finite difference. However, the epsilon of <code class="docutils literal notranslate"><span class="pre">0.00000001</span></code> seems to be too small. We can set this step size to be bigger by using the <code class="docutils literal notranslate"><span class="pre">minimize()</span></code> function’s <code class="docutils literal notranslate"><span class="pre">options={}</span></code> argument.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">options={}</span></code> argument in the <code class="docutils literal notranslate"><span class="pre">minimize()</span></code> function is a dictionary of solver options available to each particular method. In our case, we want to look at the <code class="docutils literal notranslate"><span class="pre">options={}</span></code> arguments for the <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/optimize.minimize-lbfgsb.html#optimize-minimize-lbfgsb"><code class="docutils literal notranslate"><span class="pre">L-BFGS-B</span></code> method</a> of the <code class="docutils literal notranslate"><span class="pre">scipy.minimize()</span></code> function. Looking at this documentation, we find that we can set the <code class="docutils literal notranslate"><span class="pre">eps</span></code> option to something other than its default which is <code class="docutils literal notranslate"><span class="pre">options={'eps':</span> <span class="pre">1e-08}</span></code>. In our case, we want to set that epsilon value used the finite differnce estimation of the Jacobian to be something bigger. Our means and variances seem to be in the 100’s, so let’s see if we get a solution setting the epsilon equal to 1.0.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">results4_1</span> <span class="o">=</span> <span class="n">opt</span><span class="o">.</span><span class="n">minimize</span><span class="p">(</span><span class="n">criterion4</span><span class="p">,</span> <span class="n">params_init4_1</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">smm_args4_1</span><span class="p">),</span>
                          <span class="n">method</span><span class="o">=</span><span class="s1">&#39;L-BFGS-B&#39;</span><span class="p">,</span>
                          <span class="n">bounds</span><span class="o">=</span><span class="p">((</span><span class="mf">1e-10</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="p">(</span><span class="mf">1e-10</span><span class="p">,</span> <span class="kc">None</span><span class="p">)),</span>
                          <span class="n">options</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;eps&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">})</span>
<span class="n">mu_SMM4_1</span><span class="p">,</span> <span class="n">sig_SMM4_1</span> <span class="o">=</span> <span class="n">results4_1</span><span class="o">.</span><span class="n">x</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;mu_SMM4_1=&#39;</span><span class="p">,</span> <span class="n">mu_SMM4_1</span><span class="p">,</span> <span class="s1">&#39; sig_SMM4_1&#39;</span><span class="p">,</span> <span class="n">sig_SMM4_1</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">results4_1</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>mu_SMM4_1= 362.560593472098  sig_SMM4_1 46.5751519565219
  message: CONVERGENCE: REL_REDUCTION_OF_F_&lt;=_FACTR*EPSMCH
  success: True
   status: 0
      fun: 0.9819514324825378
        x: [ 3.626e+02  4.658e+01]
      nit: 8
      jac: [ 2.845e-03 -1.022e-03]
     nfev: 144
     njev: 48
 hess_inv: &lt;2x2 LbfgsInvHessProduct with dtype=float64&gt;
</pre></div>
</div>
</div>
</div>
<p><a class="reference internal" href="#figsmm-econ381-smm4-1"><span class="std std-numref">Figure 7</span></a> shows the plot the PDF implied by these results <span class="math notranslate nohighlight">\(\hat{\mu}=362.2\)</span> and <span class="math notranslate nohighlight">\(\hat{\sigma}=46.6\)</span> against the histogram of the data.</p>
<div class="cell tag_hide-input tag_remove-output docutils container">
<details class="hide above-input">
<summary aria-label="Toggle hidden content">
<span class="collapsed">Show code cell source</span>
<span class="expanded">Hide code cell source</span>
</summary>
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Plot the histogram of the data</span>
<span class="n">count</span><span class="p">,</span> <span class="n">bins</span><span class="p">,</span> <span class="n">ignored</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                <span class="n">edgecolor</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mf">1.2</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Total points&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Percent of scores&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">550</span><span class="p">])</span>  <span class="c1"># This gives the xmin and xmax to be plotted&quot;</span>

<span class="c1"># Plot the estimated SMM PDF</span>
<span class="n">dist_pts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">cut_lb</span><span class="p">,</span> <span class="n">cut_ub</span><span class="p">,</span> <span class="mi">500</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
    <span class="n">dist_pts</span><span class="p">,</span> <span class="n">trunc_norm_pdf</span><span class="p">(</span><span class="n">dist_pts</span><span class="p">,</span> <span class="n">mu_SMM4_1</span><span class="p">,</span> <span class="n">sig_SMM4_1</span><span class="p">,</span> <span class="n">cut_lb</span><span class="p">,</span> <span class="n">cut_ub</span><span class="p">),</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;1: $\mu$=</span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">mu_SMM4_1</span><span class="p">,</span><span class="w"> </span><span class="n">decimals</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="si">}</span><span class="s2">, &quot;</span> <span class="o">+</span>
            <span class="sa">f</span><span class="s2">&quot;$\sigma$=</span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">sig_SMM4_1</span><span class="p">,</span><span class="w"> </span><span class="n">decimals</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;upper left&#39;</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
</details>
</div>
<figure class="align-default" id="figsmm-econ381-smm4-1">
<a class="reference internal image-reference" href="../_images/Econ381scores_smm4_1.png"><img alt="../_images/Econ381scores_smm4_1.png" src="../_images/Econ381scores_smm4_1.png" style="height: 500px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 7 </span><span class="caption-text">SMM-estimated PDF function and data histogram, 4 moments, identity weighting matrix, Econ 381 scores (2011-2012)</span><a class="headerlink" href="#figsmm-econ381-smm4-1" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>Let’s print the data moments and the model moments as well as the error vector evaluated at the SMM estimates.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">bpct_1_data</span><span class="p">,</span> <span class="n">bpct_2_data</span><span class="p">,</span> <span class="n">bpct_3_data</span><span class="p">,</span> <span class="n">bpct_4_data</span> <span class="o">=</span> <span class="n">data_moments4</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Data moments =&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">bpct_1_data</span><span class="p">,</span> <span class="n">bpct_2_data</span><span class="p">,</span> <span class="n">bpct_3_data</span><span class="p">,</span> <span class="n">bpct_4_data</span><span class="p">)</span>
<span class="n">sim_vals4_1</span> <span class="o">=</span> <span class="n">trunc_norm_draws</span><span class="p">(</span><span class="n">unif_vals_2</span><span class="p">,</span> <span class="n">mu_SMM4_1</span><span class="p">,</span> <span class="n">sig_SMM4_1</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mi">450</span><span class="p">)</span>
<span class="n">bpct_1_sim4_1</span><span class="p">,</span> <span class="n">bpct_2_sim4_1</span><span class="p">,</span> <span class="n">bpct_3_sim4_1</span><span class="p">,</span> <span class="n">bpct_4_sim4_1</span> <span class="o">=</span> \
    <span class="n">data_moments4</span><span class="p">(</span><span class="n">sim_vals4_1</span><span class="p">)</span>
<span class="n">bpct_1_model4_1</span> <span class="o">=</span> <span class="n">bpct_1_sim4_1</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
<span class="n">bpct_2_model4_1</span> <span class="o">=</span> <span class="n">bpct_2_sim4_1</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
<span class="n">bpct_3_model4_1</span> <span class="o">=</span> <span class="n">bpct_3_sim4_1</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
<span class="n">bpct_4_model4_1</span> <span class="o">=</span> <span class="n">bpct_4_sim4_1</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Model moments =&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">bpct_1_model4_1</span><span class="p">,</span> <span class="n">bpct_2_model4_1</span><span class="p">,</span> <span class="n">bpct_3_model4_1</span><span class="p">,</span> <span class="n">bpct_4_model4_1</span><span class="p">)</span>
<span class="n">err4_1</span> <span class="o">=</span> <span class="n">err_vec4</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">unif_vals_2</span><span class="p">,</span> <span class="n">mu_SMM4_1</span><span class="p">,</span> <span class="n">sig_SMM4_1</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mi">450</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
<span class="n">crit_params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">mu_SMM4_1</span><span class="p">,</span> <span class="n">sig_SMM4_1</span><span class="p">])</span>
<span class="n">criterion4_1</span> <span class="o">=</span> <span class="n">criterion4</span><span class="p">(</span><span class="n">crit_params</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">unif_vals_2</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mi">450</span><span class="p">,</span> <span class="n">W_hat4_1</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Error vector (pct. dev.) =&#39;</span><span class="p">,</span> <span class="n">err4_1</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">4</span><span class="p">,))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Criterion func val=&#39;</span><span class="p">,</span> <span class="n">criterion4_1</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Data moments =
0.08695652173913043 0.17391304347826086 0.6894409937888198 0.049689440993788817

Model moments =
0.0017391304347826085 0.1820496894409938 0.7702484472049688 0.04596273291925465

Error vector (pct. dev.) = [-0.98        0.04678571  0.11720721 -0.075     ]

Criterion func val= 0.9819514324825378
</pre></div>
</div>
</div>
</div>
<p>We can compute the estimator of the variance-covariance matrix <span class="math notranslate nohighlight">\(\hat{\Sigma}\)</span> of the SMM parameter estimator by computing the Jacobian of the error vector. In this case, the Jacobian <span class="math notranslate nohighlight">\(d(\tilde{x},x|\theta)\)</span> is <span class="math notranslate nohighlight">\(R\times K = 4\times 2\)</span>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">Jac_err4</span><span class="p">(</span><span class="n">data_vals</span><span class="p">,</span> <span class="n">unif_vals</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">cut_lb</span><span class="p">,</span> <span class="n">cut_ub</span><span class="p">,</span> <span class="n">simple</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    This function computes the Jacobian matrix of partial derivatives of the R x 1 moment</span>
<span class="sd">    error vector e(x|theta) with respect to the K parameters theta_i in the K x 1 parameter vector</span>
<span class="sd">    theta. The resulting matrix is R x K Jacobian.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">Jac_err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
    <span class="n">h_mu</span> <span class="o">=</span> <span class="mf">1e-4</span> <span class="o">*</span> <span class="n">mu</span>
    <span class="n">h_sig</span> <span class="o">=</span> <span class="mf">1e-4</span> <span class="o">*</span> <span class="n">sigma</span>
    <span class="n">Jac_err</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> \
        <span class="p">((</span><span class="n">err_vec4</span><span class="p">(</span><span class="n">data_vals</span><span class="p">,</span> <span class="n">unif_vals</span><span class="p">,</span> <span class="n">mu</span> <span class="o">+</span> <span class="n">h_mu</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">cut_lb</span><span class="p">,</span> <span class="n">cut_ub</span><span class="p">,</span> <span class="n">simple</span><span class="p">)</span> <span class="o">-</span>
          <span class="n">err_vec4</span><span class="p">(</span><span class="n">data_vals</span><span class="p">,</span> <span class="n">unif_vals</span><span class="p">,</span> <span class="n">mu</span> <span class="o">-</span> <span class="n">h_mu</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">cut_lb</span><span class="p">,</span> <span class="n">cut_ub</span><span class="p">,</span> <span class="n">simple</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">h_mu</span><span class="p">))</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="n">Jac_err</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> \
        <span class="p">((</span><span class="n">err_vec4</span><span class="p">(</span><span class="n">data_vals</span><span class="p">,</span> <span class="n">unif_vals</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">sigma</span> <span class="o">+</span> <span class="n">h_sig</span><span class="p">,</span> <span class="n">cut_lb</span><span class="p">,</span> <span class="n">cut_ub</span><span class="p">,</span> <span class="n">simple</span><span class="p">)</span> <span class="o">-</span>
          <span class="n">err_vec4</span><span class="p">(</span><span class="n">data_vals</span><span class="p">,</span> <span class="n">unif_vals</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">sigma</span> <span class="o">-</span> <span class="n">h_sig</span><span class="p">,</span> <span class="n">cut_lb</span><span class="p">,</span> <span class="n">cut_ub</span><span class="p">,</span> <span class="n">simple</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">h_sig</span><span class="p">))</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">Jac_err</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">d_err4_1</span> <span class="o">=</span> <span class="n">Jac_err4</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">unif_vals_2</span><span class="p">,</span> <span class="n">mu_SMM4_1</span><span class="p">,</span> <span class="n">sig_SMM4_1</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">450.0</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Jacobian matrix of derivatives of moment error functions (4 x 2) is:&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">d_err4_1</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Estimate of optimal weighting matrix is identity matrix (4 x 4):&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">W_hat4_1</span><span class="p">)</span>
<span class="n">SigHat4_1</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">S</span><span class="p">)</span> <span class="o">*</span> <span class="n">lin</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">d_err4_1</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">W_hat4_1</span> <span class="o">@</span> <span class="n">d_err4_1</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Variance-covariance matrix of estimated parameter vector is:&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">SigHat4_1</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Std. err. mu_hat=&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">SigHat4_1</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Std. err. sig_hat=&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">SigHat4_1</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Jacobian matrix of derivatives of moment error functions (4 x 2) is:
[[ 0.          0.        ]
 [-0.05417814  0.07668099]
 [ 0.01242414 -0.01934295]
 [ 0.0172385   0.        ]]

Estimate of optimal weighting matrix is identity matrix (4 x 4):
[[1. 0. 0. 0.]
 [0. 1. 0. 0.]
 [0. 0. 1. 0.]
 [0. 0. 0. 1.]]

Variance-covariance matrix of estimated parameter vector is:
[[33.48770545 23.53170341]
 [23.53170341 18.13459776]]

Std. err. mu_hat= 5.786856266717126
Std. err. sig_hat= 4.258473642422245
</pre></div>
</div>
</div>
</div>
</section>
<section id="four-moments-two-step-optimal-weighting-matrix">
<span id="secsmm-codeexmp-macrtest-4m2st"></span><h4>Four moments, two-step optimal weighting matrix<a class="headerlink" href="#four-moments-two-step-optimal-weighting-matrix" title="Permalink to this heading">#</a></h4>
<p>Let’s see how much things change if we use the two-step estimator for the optimal weighting matrix <span class="math notranslate nohighlight">\(W\)</span> instead of the identity matrix.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_Err_mat4</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">unif_vals</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">cut_lb</span><span class="p">,</span> <span class="n">cut_ub</span><span class="p">,</span> <span class="n">simple</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    --------------------------------------------------------------------</span>
<span class="sd">    This function computes the R x S matrix of errors from each</span>
<span class="sd">    simulated moment for each moment error. In this function, we have</span>
<span class="sd">    hard coded R = 4.</span>
<span class="sd">    --------------------------------------------------------------------</span>
<span class="sd">    INPUTS:</span>
<span class="sd">    xvals     = (N,) vector, test scores data</span>
<span class="sd">    unif_vals = (N, S) matrix, uniform random variables that generate</span>
<span class="sd">                the N observations of simulated data for S simulations</span>
<span class="sd">    mu        = scalar, mean of the normally distributed random variable</span>
<span class="sd">    sigma     = scalar &gt; 0, standard deviation of the normally</span>
<span class="sd">                distributed random variable</span>
<span class="sd">    cut_lb    = scalar or string, =&#39;None&#39; if no cutoff is given,</span>
<span class="sd">                otherwise is scalar lower bound value of distribution.</span>
<span class="sd">                Values below this value have zero probability</span>
<span class="sd">    cut_ub    = scalar or string, =&#39;None&#39; if no cutoff is given,</span>
<span class="sd">                otherwise is scalar upper bound value of distribution.</span>
<span class="sd">                Values above this value have zero probability</span>
<span class="sd">    simple    = boolean, =True if errors are simple difference, =False</span>
<span class="sd">                if errors are percent deviation from data moments</span>

<span class="sd">    OTHER FUNCTIONS AND FILES CALLED BY THIS FUNCTION:</span>
<span class="sd">        model_moments()</span>

<span class="sd">    OBJECTS CREATED WITHIN FUNCTION:</span>
<span class="sd">    R          = integer = 4, hard coded number of moments</span>
<span class="sd">    S          = integer &gt;= R, number of simulated datasets</span>
<span class="sd">    Err_mat    = (R, S) matrix, error by moment and simulated data</span>
<span class="sd">    mean_model = scalar, mean value from model</span>
<span class="sd">    var_model  = scalar &gt; 0, variance from model</span>

<span class="sd">    FILES CREATED BY THIS FUNCTION: None</span>

<span class="sd">    RETURNS: Err_mat</span>
<span class="sd">    --------------------------------------------------------------------</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">R</span> <span class="o">=</span> <span class="mi">4</span>
    <span class="n">S</span> <span class="o">=</span> <span class="n">unif_vals</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">Err_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">R</span><span class="p">,</span> <span class="n">S</span><span class="p">))</span>
    <span class="n">bpct_1_dat</span><span class="p">,</span> <span class="n">bpct_2_dat</span><span class="p">,</span> <span class="n">bpct_3_dat</span><span class="p">,</span> <span class="n">bpct_4_dat</span> <span class="o">=</span> <span class="n">data_moments4</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">sim_vals</span> <span class="o">=</span> <span class="n">trunc_norm_draws</span><span class="p">(</span><span class="n">unif_vals</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">cut_lb</span><span class="p">,</span> <span class="n">cut_ub</span><span class="p">)</span>
    <span class="n">bpct_1_sim</span><span class="p">,</span> <span class="n">bpct_2_sim</span><span class="p">,</span> <span class="n">bpct_3_sim</span><span class="p">,</span> <span class="n">bpct_4_sim</span> <span class="o">=</span> <span class="n">data_moments4</span><span class="p">(</span><span class="n">sim_vals</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">simple</span><span class="p">:</span>
        <span class="n">Err_mat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">bpct_1_sim</span> <span class="o">-</span> <span class="n">bpct_1_dat</span>
        <span class="n">Err_mat</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">bpct_2_sim</span> <span class="o">-</span> <span class="n">bpct_2_dat</span>
        <span class="n">Err_mat</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">bpct_3_sim</span> <span class="o">-</span> <span class="n">bpct_3_dat</span>
        <span class="n">Err_mat</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">bpct_4_sim</span> <span class="o">-</span> <span class="n">bpct_4_dat</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">Err_mat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">(</span><span class="n">bpct_1_sim</span> <span class="o">-</span> <span class="n">bpct_1_dat</span><span class="p">)</span> <span class="o">/</span> <span class="n">bpct_1_dat</span>
        <span class="n">Err_mat</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">(</span><span class="n">bpct_2_sim</span> <span class="o">-</span> <span class="n">bpct_2_dat</span><span class="p">)</span> <span class="o">/</span> <span class="n">bpct_2_dat</span>
        <span class="n">Err_mat</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">(</span><span class="n">bpct_3_sim</span> <span class="o">-</span> <span class="n">bpct_3_dat</span><span class="p">)</span> <span class="o">/</span> <span class="n">bpct_3_dat</span>
        <span class="n">Err_mat</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">(</span><span class="n">bpct_4_sim</span> <span class="o">-</span> <span class="n">bpct_4_dat</span><span class="p">)</span> <span class="o">/</span> <span class="n">bpct_4_dat</span>

    <span class="k">return</span> <span class="n">Err_mat</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">Err_mat4</span> <span class="o">=</span> <span class="n">get_Err_mat4</span><span class="p">(</span>
    <span class="n">data</span><span class="p">,</span> <span class="n">unif_vals_2</span><span class="p">,</span> <span class="n">mu_SMM4_1</span><span class="p">,</span> <span class="n">sig_SMM4_1</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">450.0</span><span class="p">,</span> <span class="kc">False</span>
<span class="p">)</span>
<span class="n">VCV4</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">S</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">Err_mat4</span> <span class="o">@</span> <span class="n">Err_mat4</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;2nd stage est. of var-cov matrix of moment error vec across sims (4 x 4):&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">VCV4</span><span class="p">)</span>
<span class="c1"># Because VCV4 is poorly conditioned we use the pseudo-inverse to invert it,</span>
<span class="c1"># which uses the singular value decomposition (SVD)</span>
<span class="n">W_hat4_2</span> <span class="o">=</span> <span class="n">lin</span><span class="o">.</span><span class="n">pinv</span><span class="p">(</span><span class="n">VCV4</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;2nd state est. of optimal weighting matrix (4 x 4):&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">W_hat4_2</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>2nd stage est. of var-cov matrix of moment error vec across sims (4 x 4):
[[ 9.61938776e-01 -4.52040816e-02 -1.15173745e-01  7.28571429e-02]
 [-4.52040816e-02  2.66198980e-02 -5.27670528e-04 -6.74107143e-03]
 [-1.15173745e-01 -5.27670528e-04  1.57738820e-02 -1.54617117e-02]
 [ 7.28571429e-02 -6.74107143e-03 -1.54617117e-02  1.10625000e-01]]

2nd state est. of optimal weighting matrix (4 x 4):
[[ 1.08330385  0.5343057  -0.21471629 -0.78666313]
 [ 0.5343057  36.19111144 -9.22640243  0.41240869]
 [-0.21471629 -9.22640243  2.40386307 -0.68543805]
 [-0.78666313  0.41240869 -0.68543805  9.443683  ]]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">params_init4_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">mu_SMM4_1</span><span class="p">,</span> <span class="n">sig_SMM4_1</span><span class="p">])</span>
<span class="c1"># params_init2_2 = np.array([400, 70])</span>
<span class="c1"># W_hat[1, 1] = 2.0</span>
<span class="c1"># W_hat[2, 2] = 2.0</span>
<span class="n">smm_args4_2</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">unif_vals_2</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mi">450</span><span class="p">,</span> <span class="n">W_hat4_2</span><span class="p">)</span>
<span class="n">results4_2</span> <span class="o">=</span> <span class="n">opt</span><span class="o">.</span><span class="n">minimize</span><span class="p">(</span><span class="n">criterion4</span><span class="p">,</span> <span class="n">params_init4_2</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">smm_args4_2</span><span class="p">),</span>
                          <span class="n">method</span><span class="o">=</span><span class="s1">&#39;SLSQP&#39;</span><span class="p">,</span>
                          <span class="n">bounds</span><span class="o">=</span><span class="p">((</span><span class="mf">1e-10</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="p">(</span><span class="mf">1e-10</span><span class="p">,</span> <span class="kc">None</span><span class="p">)),</span>
                          <span class="n">options</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;eps&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">})</span>
<span class="n">mu_SMM4_2</span><span class="p">,</span> <span class="n">sig_SMM4_2</span> <span class="o">=</span> <span class="n">results4_2</span><span class="o">.</span><span class="n">x</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;mu_SMM4_2=&#39;</span><span class="p">,</span> <span class="n">mu_SMM4_2</span><span class="p">,</span> <span class="s1">&#39; sig_SMM4_2&#39;</span><span class="p">,</span> <span class="n">sig_SMM4_2</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">results4_2</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>mu_SMM4_2= 362.5605400454758  sig_SMM4_2 46.57507128065564
 message: Optimization terminated successfully
 success: True
  status: 0
     fun: 0.9984266286568926
       x: [ 3.626e+02  4.658e+01]
     nit: 1
     jac: [ 5.467e-02  8.255e-02]
    nfev: 14
    njev: 1
</pre></div>
</div>
</div>
</div>
<p>As can be seen in the SMM point estimates above of <span class="math notranslate nohighlight">\(\hat{\mu}=362.6\)</span> and <span class="math notranslate nohighlight">\(\hat{\sigma}=46.6\)</span>, the optimal weighting matrix <span class="math notranslate nohighlight">\(\hat{W}_{2step}\)</span> does not make a difference on the point estimates. This means that the plot of the SMM-estimated truncated normal distribution with the 2-step optimal weighting matrix is almost exactly the same as the one estimated with the identity matrix, shown in <a class="reference internal" href="#figsmm-econ381-smm4-1"><span class="std std-numref">Figure 7</span></a>. But the two-step optimal weighting matrix will make a difference on the standard errors.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Data moments =&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">bpct_1_data</span><span class="p">,</span> <span class="n">bpct_2_data</span><span class="p">,</span> <span class="n">bpct_3_data</span><span class="p">,</span> <span class="n">bpct_4_data</span><span class="p">)</span>
<span class="n">sim_vals4_2</span> <span class="o">=</span> <span class="n">trunc_norm_draws</span><span class="p">(</span><span class="n">unif_vals_2</span><span class="p">,</span> <span class="n">mu_SMM4_2</span><span class="p">,</span> <span class="n">sig_SMM4_2</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mi">450</span><span class="p">)</span>
<span class="n">bpct_1_sim4_2</span><span class="p">,</span> <span class="n">bpct_2_sim4_2</span><span class="p">,</span> <span class="n">bpct_3_sim4_2</span><span class="p">,</span> <span class="n">bpct_4_sim4_2</span> <span class="o">=</span> \
    <span class="n">data_moments4</span><span class="p">(</span><span class="n">sim_vals4_2</span><span class="p">)</span>
<span class="n">bpct_1_model4_2</span> <span class="o">=</span> <span class="n">bpct_1_sim4_2</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
<span class="n">bpct_2_model4_2</span> <span class="o">=</span> <span class="n">bpct_2_sim4_2</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
<span class="n">bpct_3_model4_2</span> <span class="o">=</span> <span class="n">bpct_3_sim4_2</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
<span class="n">bpct_4_model4_2</span> <span class="o">=</span> <span class="n">bpct_4_sim4_2</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Model moments =&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">bpct_1_model4_2</span><span class="p">,</span> <span class="n">bpct_2_model4_2</span><span class="p">,</span> <span class="n">bpct_3_model4_2</span><span class="p">,</span> <span class="n">bpct_4_model4_2</span><span class="p">)</span>
<span class="n">err4_2</span> <span class="o">=</span> <span class="n">err_vec4</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">unif_vals_2</span><span class="p">,</span> <span class="n">mu_SMM4_2</span><span class="p">,</span> <span class="n">sig_SMM4_2</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mi">450</span><span class="p">,</span>
                  <span class="kc">False</span><span class="p">)</span>
<span class="n">crit_params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">mu_SMM4_2</span><span class="p">,</span> <span class="n">sig_SMM4_2</span><span class="p">])</span>
<span class="n">criterion4_2</span> <span class="o">=</span> <span class="n">criterion4</span><span class="p">(</span><span class="n">crit_params</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">unif_vals_2</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mi">450</span><span class="p">,</span> <span class="n">W_hat4_2</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Error vector (pct. dev.) =&#39;</span><span class="p">,</span> <span class="n">err4_2</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">4</span><span class="p">,))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Criterion func val =&#39;</span><span class="p">,</span> <span class="n">criterion4_2</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Data moments =
0.08695652173913043 0.17391304347826086 0.6894409937888198 0.049689440993788817

Model moments =
0.0017391304347826085 0.1820496894409938 0.7702484472049688 0.04596273291925465

Error vector (pct. dev.) = [-0.98        0.04678571  0.11720721 -0.075     ]

Criterion func val = 0.9984266286568926
</pre></div>
</div>
</div>
</div>
<p>The criterion function for different values of <span class="math notranslate nohighlight">\(\mu\)</span> and <span class="math notranslate nohighlight">\(\sigma\)</span> in this problem with four moments <span class="math notranslate nohighlight">\(R=4\)</span> has a minimum, although it looks like there is a valley floor ridge along which values of <span class="math notranslate nohighlight">\(\mu\)</span> and <span class="math notranslate nohighlight">\(\sigma\)</span> produce approximately the same criterion function value.</p>
<div class="cell tag_remove-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">mu_vals4</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">340</span><span class="p">,</span> <span class="mi">380</span><span class="p">,</span> <span class="mi">90</span><span class="p">)</span>
<span class="n">sig_vals4</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">70</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="c1"># mu_vals = np.linspace(350, 370, 50)</span>
<span class="c1"># sig_vals = np.linspace(85, 98, 50)</span>
<span class="n">crit_vals4</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">90</span><span class="p">,</span> <span class="mi">100</span><span class="p">))</span>
<span class="n">crit_args4</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">unif_vals_2</span><span class="p">,</span> <span class="n">cut_lb</span><span class="p">,</span> <span class="n">cut_ub</span><span class="p">,</span> <span class="n">W_hat4_2</span><span class="p">)</span>
<span class="k">for</span> <span class="n">mu_ind</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">90</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">sig_ind</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">100</span><span class="p">):</span>
        <span class="n">crit_params4</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">mu_vals4</span><span class="p">[</span><span class="n">mu_ind</span><span class="p">],</span> <span class="n">sig_vals4</span><span class="p">[</span><span class="n">sig_ind</span><span class="p">]])</span>
        <span class="n">crit_vals4</span><span class="p">[</span><span class="n">mu_ind</span><span class="p">,</span> <span class="n">sig_ind</span><span class="p">]</span> <span class="o">=</span> \
            <span class="n">criterion4</span><span class="p">(</span><span class="n">crit_params4</span><span class="p">,</span> <span class="o">*</span><span class="n">crit_args4</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

<span class="n">mu_mesh4</span><span class="p">,</span> <span class="n">sig_mesh4</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">mu_vals4</span><span class="p">,</span> <span class="n">sig_vals4</span><span class="p">)</span>

<span class="n">crit_SMM4_2</span> <span class="o">=</span> <span class="n">criterion4</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">mu_SMM4_2</span><span class="p">,</span> <span class="n">sig_SMM4_2</span><span class="p">]),</span> <span class="o">*</span><span class="n">crit_args4</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">subplot_kw</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;projection&quot;</span><span class="p">:</span> <span class="s2">&quot;3d&quot;</span><span class="p">})</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot_surface</span><span class="p">(</span><span class="n">mu_mesh4</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">sig_mesh4</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">crit_vals4</span><span class="p">,</span> <span class="n">rstride</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span>
                <span class="n">cstride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap1</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.9</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">mu_SMM4_2</span><span class="p">,</span> <span class="n">sig_SMM4_2</span><span class="p">,</span> <span class="n">crit_SMM4_2</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;o&#39;</span><span class="p">,</span>
           <span class="n">s</span><span class="o">=</span><span class="mi">18</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;SMM4 estimate&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">view_init</span><span class="p">(</span><span class="n">elev</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">azim</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">roll</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Criterion function for values of mu and sigma&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$\mu$&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$\sigma$&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_zlabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;Crit. func.&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>

<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<figure class="align-default" id="figsmm-econ381-crit4">
<a class="reference internal image-reference" href="../_images/Econ381_crit4.png"><img alt="../_images/Econ381_crit4.png" src="../_images/Econ381_crit4.png" style="height: 500px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 8 </span><span class="caption-text">Criterion function surface for values of <span class="math notranslate nohighlight">\(\mu\)</span> and <span class="math notranslate nohighlight">\(\sigma\)</span> for SMM estimation of truncated normal with four moments and 2-step optimal weighting matrix (SMM estimate shown as red dot)</span><a class="headerlink" href="#figsmm-econ381-crit4" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>As has been true in our other examples of GMM and SMM, the standard errors on the estimated parameter vector decrease substantially with the incorporation of an optimal weighting matrix.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">d_err4_2</span> <span class="o">=</span> <span class="n">Jac_err4</span><span class="p">(</span>
    <span class="n">data</span><span class="p">,</span> <span class="n">unif_vals_2</span><span class="p">,</span> <span class="n">mu_SMM4_2</span><span class="p">,</span> <span class="n">sig_SMM4_2</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">450.0</span><span class="p">,</span> <span class="kc">False</span>
<span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Jacobian matrix of derivatives of moment error functions (4 x 2) is:&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">d_err4_2</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;2-step estimate of optimal weighting matrix (4 x 4) is:&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">W_hat4_2</span><span class="p">)</span>
<span class="n">SigHat4_2</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">S</span><span class="p">)</span> <span class="o">*</span> <span class="n">lin</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">d_err4_2</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">W_hat4_2</span> <span class="o">@</span> <span class="n">d_err4_2</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Variance-covariance matrix of estimated parameter vector is:&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">SigHat4_2</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Std. err. mu_hat=&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">SigHat4_2</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Std. err. sig_hat=&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">SigHat4_2</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Jacobian matrix of derivatives of moment error functions (4 x 2) is:
[[ 0.          0.        ]
 [-0.05417814  0.07668112]
 [ 0.01242414 -0.01934298]
 [ 0.0172385   0.        ]]

2-step estimate of optimal weighting matrix (4 x 4) is:
[[ 1.08330385  0.5343057  -0.21471629 -0.78666313]
 [ 0.5343057  36.19111144 -9.22640243  0.41240869]
 [-0.21471629 -9.22640243  2.40386307 -0.68543805]
 [-0.78666313  0.41240869 -0.68543805  9.443683  ]]

Variance-covariance matrix of estimated parameter vector is:
[[3.53697411 2.47391182]
 [2.47391182 1.77184156]]

Std. err. mu_hat= 1.8806844791000217
Std. err. sig_hat= 1.3311053920876885
</pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="brock-and-mirman-1972-estimation-by-smm">
<span id="secsmm-codeexmp-bm72"></span><h3>Brock and Mirman (1972) estimation by SMM<a class="headerlink" href="#brock-and-mirman-1972-estimation-by-smm" title="Permalink to this heading">#</a></h3>
<p>In <a class="reference internal" href="#ExercStructEst_SMM_BM72"><span class="std std-numref">Exercise 56</span></a>, you will estimate four parameters in the <span id="id12">[<a class="reference internal" href="../CompMethods_references.html#id6" title="William A. Brock and Leonard J. Mirman. Optimal economic growth and uncertainty: the discounted case. Journal of Economic Theory, 4(3):479-513, June 1972.">Brock and Mirman, 1972</a>]</span> macroeconomic model by simulating the model to get six moments.</p>
</section>
</section>
<section id="secsmm-ident">
<span id="identification"></span><h2>Identification<a class="headerlink" href="#secsmm-ident" title="Permalink to this heading">#</a></h2>
<p>An issue that we saw in the examples from the previous section is that there is some science as well as some art in choosing moments to identify the parameters in an SMM estimation as well as in GMM. Suppose the parameter vector <span class="math notranslate nohighlight">\(\theta\)</span> has <span class="math notranslate nohighlight">\(K\)</span> elements, or rather, <span class="math notranslate nohighlight">\(K\)</span> parameters to be estimated. In order to estimate <span class="math notranslate nohighlight">\(\theta\)</span> by GMM, you must have at least as many moments as parameters to estimate <span class="math notranslate nohighlight">\(R\geq K\)</span>. If you have exactly as many moments as parameters to be estimated <span class="math notranslate nohighlight">\(R=K\)</span>, the model is said to be <em>exactly identified</em>. If you have more moments than parameters to be estimated <span class="math notranslate nohighlight">\(R&gt;K\)</span>, the model is said to be <em>overidentified</em>. If you have fewer moments than parameters to be estimated <span class="math notranslate nohighlight">\(R&lt;K\)</span>, the model is said to be <em>underidentified</em>. There are good reasons to overidentify <span class="math notranslate nohighlight">\(R&gt;K\)</span> the model in SMM estimation as we saw in the previous example. The main reason is that not all moments are orthogonal. That is, some moments convey roughly the same information about the data and, therefore, do not separately identify any extra parameters. So a good SMM model often is overidentified <span class="math notranslate nohighlight">\(R&gt;K\)</span>.</p>
<p>One last point about MM regards moment selection and verification of results. The real world has an infinite supply of potential moments that describe some part of the data. Choosing moments to estimate parameters by SMM requires understanding of the model, intuition about its connections to the real world, and artistry. A good SMM estimation will include moments that have some relation to or story about their connection to particular parameters of the model to be estimated. In addition, a good verification of a SMM estimation is to take some moment from the data that was not used in the estimation and see how well the corresponding moment from the estimated model matches that <em>outside moment</em>.</p>
</section>
<section id="indirect-inference">
<span id="secsmm-indirinf"></span><h2>Indirect inference<a class="headerlink" href="#indirect-inference" title="Permalink to this heading">#</a></h2>
<p>Indirect inference is a particular application of SMM with some specific characteristics. As moments to match it uses parameters of an auxiliary model that can be estimated both on the real-world data and on the simulated data. <span id="id13">[<a class="reference internal" href="../CompMethods_references.html#id44" title="Anthony A. Jr. Smith. Indirect inference. In Matias Vernengo, Esteban Perez Caldentey, and Barkley J. Rosser Jr., editors, New Palgrave Dictionary of Economics. Palgrave MacMillan, 2020. URL: http://www.econ.yale.edu/smith/palgrave7.pdf.">Smith, 2020</a>]</span> gives a great summary of the topic with some examples. See also <span id="id14">[<a class="reference internal" href="../CompMethods_references.html#id31" title="Christian Gourieroux and Alain Monfort. Simulation-based Econometric Methods. Oxford University Press, 1996.">Gourieroux and Monfort, 1996</a>]</span> (ch. 4) for a textbook treatment of the topic.</p>
<section id="restatement-of-the-general-smm-estimation-problem">
<span id="secsmm-indirinf-smmprob"></span><h3>Restatement of the general SMM estimation problem<a class="headerlink" href="#restatement-of-the-general-smm-estimation-problem" title="Permalink to this heading">#</a></h3>
<p>Define a model or data generating process (DGP) as a system of equations,</p>
<div class="math notranslate nohighlight">
\[ G(x_t,z_t|\theta)=0 \]</div>
<p>which are functions of a vector of endogenous variables <span class="math notranslate nohighlight">\(x_t\)</span>, exogenous variables <span class="math notranslate nohighlight">\(z_t\)</span>, and parameters <span class="math notranslate nohighlight">\(\theta\)</span>. In the general simulated method of moments (SMM) estimation approach, one would choose data moments <span class="math notranslate nohighlight">\(m(x_t,z_t)\)</span> that are just statistics of the data and model moments <span class="math notranslate nohighlight">\(\hat{m}(\tilde{x}_t,\tilde{z}_t|\theta)\)</span> that are averages of the same data moments calculated on simulated samples of the data. The SMM estimator is to choose the parameter vector <span class="math notranslate nohighlight">\(\hat{\theta}_{SMM}\)</span> to minimize some distance of the model moments from the data moments.</p>
<div class="math notranslate nohighlight">
\[ \hat{\theta}_{SMM}=\theta:\quad \min_{\theta} ||\hat{m}(\tilde{x}_t,\tilde{z}_t|\theta) - m(x_t,z_t)|| \]</div>
</section>
<section id="indirect-inference-estimation-problem">
<span id="secsmm-indirinf-indinfprob"></span><h3>Indirect inference estimation problem<a class="headerlink" href="#indirect-inference-estimation-problem" title="Permalink to this heading">#</a></h3>
<p>Indirect inference is to change the model moments from being stastics that are calculated directly from the simulated data to being statistics that are calculated indirectly from the simulated data. These indirect inference model moments are parameters from an auxiliary model.</p>
<p>Let an auxiliary model be defined as <span class="math notranslate nohighlight">\(H(x_t,z_t|\phi)=0\)</span>. The parameters of the auxiliary model <span class="math notranslate nohighlight">\(\phi\)</span> will be the moments we use to identify the model parameters <span class="math notranslate nohighlight">\(\theta\)</span>. Suppose that the model parameter vector <span class="math notranslate nohighlight">\(\theta\)</span> has <span class="math notranslate nohighlight">\(K\)</span> elements. Then the auxiliary model parameter vector <span class="math notranslate nohighlight">\(\phi\)</span> must have <span class="math notranslate nohighlight">\(R\)</span> elements such that <span class="math notranslate nohighlight">\(R\geq K\)</span>. This is the typical identification restriction that the number of model moments must be at least as many as the number of model parameters being estimated.</p>
<p>When the auxiliary model is run on real-world data <span class="math notranslate nohighlight">\(H(x_t,z_t|\phi)=0\)</span>, the resulting values of the auxiliary model parameters are the data moments <span class="math notranslate nohighlight">\(\hat{\phi}(x_t,z_t)\)</span>. Note that these data moments <span class="math notranslate nohighlight">\(\hat{\phi}\)</span> have a hat on them to represent that these moments are usually estimated in some way. When the auxiliary model is run on the <span class="math notranslate nohighlight">\(s\)</span>th simulation of the data given model parameters <span class="math notranslate nohighlight">\(H(\tilde{x}_{s,t},\tilde{z}_{s,t}|\phi)=0\)</span>, the auxiliary model parameters are the <span class="math notranslate nohighlight">\(s\)</span>th estimate of the model moments <span class="math notranslate nohighlight">\(\hat{\phi}_s(\tilde{x}_{s,t},\tilde{z}_{s,t}|\theta)\)</span>. The model moments are then the average of these auxiliary model parameter estimates across the simulations.</p>
<div class="math notranslate nohighlight">
\[ \hat{\phi}(\tilde{x}_{t},\tilde{z}_{t}|\theta) = \frac{1}{S}\sum_{s=1}^S \hat{\phi}_s(\tilde{x}_{s,t},\tilde{z}_{s,t}|\theta) \]</div>
<p>The indirect inference estimation method is simply to choose a model parameter vector <span class="math notranslate nohighlight">\(\theta\)</span> that minimizes some distance metric between the model moments <span class="math notranslate nohighlight">\(\hat{\phi}(\tilde{x}_{t},\tilde{z}_{t}|\theta)\)</span> and the data moments <span class="math notranslate nohighlight">\(\hat{\phi}(x_t,z_t)\)</span>.</p>
<div class="math notranslate nohighlight">
\[ \hat{\theta}_{SMM}=\theta:\quad \min_{\theta} ||\hat{\phi}(\tilde{x}_{t},\tilde{z}_{t}|\theta) - \hat{\phi}(x_t,z_t)|| \]</div>
<p>In most examples of indirect, the data moments and model moments are some regression of endogenous variables on exogenous variables. In the univariate case, it is usually linear regression. In the multivariate case, it is usually a vector autoregression (VAR). But most examples are reduced form parameter estimation exercises. Other examples are probit, logit, and two-stage IV regressions. The key is that these statistics be computationally tractable and have convenient or accurate data availability.</p>
</section>
<section id="hypothesis-testing-with-indirect-inference">
<span id="secsmm-indirinf-hypothtest"></span><h3>Hypothesis testing with indirect inference<a class="headerlink" href="#hypothesis-testing-with-indirect-inference" title="Permalink to this heading">#</a></h3>
<ul class="simple">
<li><p>Wald test</p></li>
<li><p>likelihood ratio test</p></li>
</ul>
</section>
</section>
<section id="exercises">
<span id="secsmm-exerc"></span><h2>Exercises<a class="headerlink" href="#exercises" title="Permalink to this heading">#</a></h2>
<div class="exercise green admonition" id="ExercStructEst_SMM_BM72">

<p class="admonition-title"><span class="caption-number">Exercise 56 </span> (Estimating the Brock and Mirman (1972) model by SMM)</p>
<section id="exercise-content">
<p>You can observe time series data in an economy for the following variables: <span class="math notranslate nohighlight">\((c_t, k_t, w_t, r_t, y_t)\)</span>. The data can be loaded from the file <a class="reference external" href="https://github.com/OpenSourceEcon/CompMethods/blob/main/data/smm/NewMacroSeries.txt"><code class="docutils literal notranslate"><span class="pre">NewMacroSeries.txt</span></code></a> in the online book repository data folder <code class="docutils literal notranslate"><span class="pre">data/smm/</span></code>. This file is a comma separated text file with no labels. The variables are ordered as <span class="math notranslate nohighlight">\((c_t, k_t, w_t, r_t, y_t)\)</span>. These data have 100 periods, which are quarterly (25 years). Suppose you think that the data are generated by a process similar to the <span id="id15">[<a class="reference internal" href="../CompMethods_references.html#id6" title="William A. Brock and Leonard J. Mirman. Optimal economic growth and uncertainty: the discounted case. Journal of Economic Theory, 4(3):479-513, June 1972.">Brock and Mirman, 1972</a>]</span> paper. A simplified set of characterizing equations of the Brock and Mirman model are the following six equations.</p>
<div class="math notranslate nohighlight" id="equation-eqsmm-bm72-eul">
<span class="eqno">(38)<a class="headerlink" href="#equation-eqsmm-bm72-eul" title="Permalink to this equation">#</a></span>\[    (c_t)^{-1} - \beta E\left[r_{t+1}(c_{t+1})^{-1}\right] = 0\]</div>
<div class="math notranslate nohighlight" id="equation-eqsmm-bm72-bc">
<span class="eqno">(39)<a class="headerlink" href="#equation-eqsmm-bm72-bc" title="Permalink to this equation">#</a></span>\[    c_t + k_{t+1} - w_t - r_t k_t = 0\]</div>
<div class="math notranslate nohighlight" id="equation-eqsmm-bm72-focl">
<span class="eqno">(40)<a class="headerlink" href="#equation-eqsmm-bm72-focl" title="Permalink to this equation">#</a></span>\[    w_t - (1-\alpha)e^{z_t}(k_t)^\alpha = 0\]</div>
<div class="math notranslate nohighlight" id="equation-eqsmm-bm72-fock">
<span class="eqno">(41)<a class="headerlink" href="#equation-eqsmm-bm72-fock" title="Permalink to this equation">#</a></span>\[    r_t - \alpha e^{z_t}(k_t)^{\alpha-1} = 0\]</div>
<div class="math notranslate nohighlight" id="equation-eqsmm-bm72-zt">
<span class="eqno">(42)<a class="headerlink" href="#equation-eqsmm-bm72-zt" title="Permalink to this equation">#</a></span>\[    z_t = \rho z_{t-1} + (1-\rho)\mu + \varepsilon_t \quad\text{where}\quad \varepsilon_t\sim N(0,\sigma^2)\]</div>
<div class="math notranslate nohighlight" id="equation-eqsmm-bm72-prod">
<span class="eqno">(43)<a class="headerlink" href="#equation-eqsmm-bm72-prod" title="Permalink to this equation">#</a></span>\[    y_t = e^{z_t}(k_t)^\alpha\]</div>
<p>The variable <span class="math notranslate nohighlight">\(c_t\)</span> is aggregate consumption in period <span class="math notranslate nohighlight">\(t\)</span>, <span class="math notranslate nohighlight">\(k_{t+1}\)</span> is total household savings and investment in period <span class="math notranslate nohighlight">\(t\)</span> for which they receive a return in the next period <span class="math notranslate nohighlight">\(t+1\)</span> (this model assumes full depreciation of capital). The wage per unit of labor in period <span class="math notranslate nohighlight">\(t\)</span> is <span class="math notranslate nohighlight">\(w_t\)</span>, and the interest rate or rate of return on investment is
<span class="math notranslate nohighlight">\(r_t\)</span>. Total factor productivity is <span class="math notranslate nohighlight">\(z_t\)</span>, which follows an AR(1) process given in <a class="reference internal" href="#equation-eqsmm-bm72-zt">(42)</a>. GDP is <span class="math notranslate nohighlight">\(y_t\)</span>. The rest of the symbols in the equations are parameters that must be estimated or calibrated <span class="math notranslate nohighlight">\((\alpha, \beta, \rho, \mu, \sigma)\)</span>. The constraints on these parameters are the following.</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
  \alpha,\beta \in (0,1),\quad \mu,\sigma &gt; 0, \quad\rho\in(-1,1)
\end{equation*}\]</div>
<p>Assume that the first observation in the data file variables is <span class="math notranslate nohighlight">\(t=1\)</span>. Let <span class="math notranslate nohighlight">\(k_1\)</span> be the first observation in the data fil for the variable <span class="math notranslate nohighlight">\(k_t\)</span>. One nice property of the <span id="id16">[<a class="reference internal" href="../CompMethods_references.html#id6" title="William A. Brock and Leonard J. Mirman. Optimal economic growth and uncertainty: the discounted case. Journal of Economic Theory, 4(3):479-513, June 1972.">Brock and Mirman, 1972</a>]</span> model is that the household decision has a known analytical solution in which the optimal savings decision <span class="math notranslate nohighlight">\(k_{t+1}\)</span> is a function of the productivity shock today <span class="math notranslate nohighlight">\(z_t\)</span> and the amount of capital today <span class="math notranslate nohighlight">\(k_t\)</span>.</p>
<div class="math notranslate nohighlight" id="equation-eqsmm-bm72-pf">
<span class="eqno">(44)<a class="headerlink" href="#equation-eqsmm-bm72-pf" title="Permalink to this equation">#</a></span>\[    k_{t+1} = \alpha\beta e^{z_t}(k_t)^\alpha\]</div>
<p>With this solution <a class="reference internal" href="#equation-eqsmm-bm72-pf">(44)</a> and equations <a class="reference internal" href="#equation-eqsmm-bm72-bc">(39)</a> through <a class="reference internal" href="#equation-eqsmm-bm72-zt">(42)</a>, it is straightforward to simulate the data of the <span id="id17">[<a class="reference internal" href="../CompMethods_references.html#id6" title="William A. Brock and Leonard J. Mirman. Optimal economic growth and uncertainty: the discounted case. Journal of Economic Theory, 4(3):479-513, June 1972.">Brock and Mirman, 1972</a>]</span> model given parameters <span class="math notranslate nohighlight">\((\alpha, \beta, \rho, \mu, \sigma)\)</span>.</p>
<p>First, assume that <span class="math notranslate nohighlight">\(z_0=\mu\)</span> and that <span class="math notranslate nohighlight">\(k_1=\text{mean}(k_t)\)</span> from the data. These are initial values that will not change across simulations. Also assume that <span class="math notranslate nohighlight">\(\beta=0.99\)</span>.</p>
<p>Next, draw a matrix of <span class="math notranslate nohighlight">\(S=1,000\)</span> simulations (columns) of <span class="math notranslate nohighlight">\(T=100\)</span> (rows) from a uniform distribution <span class="math notranslate nohighlight">\(u_{s,t}\sim U(0,1)\)</span>. These draws will not change across this SMM estimation procedure.</p>
<p>For each guess of the parameter vector <span class="math notranslate nohighlight">\((\alpha,\rho,\mu,\sigma)\)</span> given <span class="math notranslate nohighlight">\(\beta=0.99\)</span>, you can use <span class="math notranslate nohighlight">\(u_{s,t}\)</span> to generate normally distributed errors <span class="math notranslate nohighlight">\(\varepsilon_{s,t}\sim N(0,\sigma^2)\)</span> using the inverse cdf of the normal distribution, where <span class="math notranslate nohighlight">\(s\)</span> is the index of the simulation number (columns).</p>
<p>With <span class="math notranslate nohighlight">\(\varepsilon_{s,t}\)</span>, <span class="math notranslate nohighlight">\(\rho\)</span>, <span class="math notranslate nohighlight">\(\mu\)</span>, and <span class="math notranslate nohighlight">\(z_0=\mu\)</span>, you can use <a class="reference internal" href="#equation-eqsmm-bm72-zt">(42)</a> to generate the simulationed values for <span class="math notranslate nohighlight">\(z_{s,t}\)</span>.</p>
<p>With <span class="math notranslate nohighlight">\(\alpha\)</span>, <span class="math notranslate nohighlight">\(\beta=0.99\)</span>, <span class="math notranslate nohighlight">\(z_{s,t}\)</span>, and <span class="math notranslate nohighlight">\(k_1\)</span>, you can use <a class="reference internal" href="#equation-eqsmm-bm72-pf">(44)</a> to generate simulated values for <span class="math notranslate nohighlight">\(k_{t+1}\)</span>.</p>
<p>With <span class="math notranslate nohighlight">\(\alpha\)</span>, <span class="math notranslate nohighlight">\(z_{s,t}\)</span>, and <span class="math notranslate nohighlight">\(k_{s,t}\)</span>, you can use <a class="reference internal" href="#equation-eqsmm-bm72-focl">(40)</a> and <a class="reference internal" href="#equation-eqsmm-bm72-fock">(41)</a> to generate simulated values for <span class="math notranslate nohighlight">\(w_{s,t}\)</span> and <span class="math notranslate nohighlight">\(r_{s,t}\)</span>, respectively.</p>
<p>With <span class="math notranslate nohighlight">\(w_{s,t}\)</span>, <span class="math notranslate nohighlight">\(r_{s,t}\)</span>, and <span class="math notranslate nohighlight">\(k_{s,t}\)</span>, you can use <a class="reference internal" href="#equation-eqsmm-bm72-bc">(39)</a> to generate simulated values for <span class="math notranslate nohighlight">\(c_{s,t}\)</span>.</p>
<p>With <span class="math notranslate nohighlight">\(\alpha\)</span>, <span class="math notranslate nohighlight">\(z_{s,t}\)</span>, and <span class="math notranslate nohighlight">\(k_{s,t}\)</span>, you can use <a class="reference internal" href="#equation-eqsmm-bm72-prod">(43)</a> to generate simulated values for <span class="math notranslate nohighlight">\(y_{s,t}\)</span>.</p>
<ol class="arabic simple">
<li><p>Estimate four parameters <span class="math notranslate nohighlight">\((\alpha, \rho,\mu,\sigma)\)</span> given <span class="math notranslate nohighlight">\(\beta=0.99\)</span> of the <span id="id18">[<a class="reference internal" href="../CompMethods_references.html#id6" title="William A. Brock and Leonard J. Mirman. Optimal economic growth and uncertainty: the discounted case. Journal of Economic Theory, 4(3):479-513, June 1972.">Brock and Mirman, 1972</a>]</span> model described by equations <a class="reference internal" href="#equation-eqsmm-bm72-eul">(38)</a> through <a class="reference internal" href="#equation-eqsmm-bm72-prod">(43)</a> and <a class="reference internal" href="#equation-eqsmm-bm72-pf">(44)</a> by SMM. Choose the four parameters to match the following six moments from the 100 periods of empirical data <span class="math notranslate nohighlight">\(\{c_t,k_t, w_t, r_t, y_t\}_{t=1}^{100}\)</span> in <a class="reference external" href="https://github.com/OpenSourceEcon/CompMethods/blob/main/data/smm/NewMacroSeries.txt"><code class="docutils literal notranslate"><span class="pre">NewMacroSeries.txt</span></code></a>: <span class="math notranslate nohighlight">\(\text{mean}(c_t)\)</span>, <span class="math notranslate nohighlight">\(\text{mean}(k_t)\)</span>, <span class="math notranslate nohighlight">\(\text{mean}(c_t/y_t)\)</span>, <span class="math notranslate nohighlight">\(\text{var}(y_t)\)</span>, <span class="math notranslate nohighlight">\(\text{corr}(c_t, c_{t-1})\)</span>, <span class="math notranslate nohighlight">\(\text{corr}(c_t, k_t)\)</span>. In your simulations of the model, set <span class="math notranslate nohighlight">\(T=100\)</span> and <span class="math notranslate nohighlight">\(S=1,000\)</span>. Input the bounds to be <span class="math notranslate nohighlight">\(\alpha\in[0.01,0.99]\)</span>, <span class="math notranslate nohighlight">\(\rho\in[-0.99,0.99]\)</span>, <span class="math notranslate nohighlight">\(\mu\in[5, 14]\)</span>, and <span class="math notranslate nohighlight">\(\sigma\in[0.01, 1.1]\)</span>.
Also, use the identity matrix as your weighting matrix <span class="math notranslate nohighlight">\(\textbf{W}=\textbf{I}\)</span> as shown in section <a class="reference internal" href="#secsmm-w-i"><span class="std std-ref">The identity matrix (W=I)</span></a>. Report your solution <span class="math notranslate nohighlight">\(\hat{\theta} = \left(\hat{\alpha},\hat{\rho},\hat{\mu},\hat{\sigma}\right)\)</span>, the vector of moment differences at the optimum, and the criterion function value. Also report your standard errors for the estimated parameter vector <span class="math notranslate nohighlight">\(\hat{\theta} = \left(\hat{\alpha},\hat{\rho},\hat{\mu},\hat{\sigma}\right)\)</span> based on the identity matrix for the optimal weighting matrix.</p></li>
<li><p>Perform the estimation using the two-step estimator for the optimal weighting matrix <span class="math notranslate nohighlight">\(\textbf{W}_{2step}\)</span>, as shown in section <a class="reference internal" href="#secsmm-w-2step"><span class="std std-ref">Two-step variance-covariance estimator of W</span></a>. Report your solution <span class="math notranslate nohighlight">\(\hat{\theta} = \left(\hat{\alpha},\hat{\rho},\hat{\mu},\hat{\sigma}\right)\)</span>, the vector of moment differences at the optimum, and the criterion function value. Also report your standard errors for the estimated parameter vector <span class="math notranslate nohighlight">\(\hat{\theta} = \left(\hat{\alpha},\hat{\rho},\hat{\mu},\hat{\sigma}\right)\)</span> based on the two-step optimal weighting matrix <span class="math notranslate nohighlight">\(\textbf{W}_{2step}\)</span>.</p></li>
</ol>
</section>
</div>
</section>
<section id="footnotes">
<span id="secsmmfootnotes"></span><h2>Footnotes<a class="headerlink" href="#footnotes" title="Permalink to this heading">#</a></h2>
<p>The footnotes from this chapter.</p>
<hr class="footnotes docutils" />
<aside class="footnote brackets" id="truncnorm" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id11">1</a><span class="fn-bracket">]</span></span>
<p>See Section <a class="reference internal" href="../appendix/appendix.html#secappendixtruncnormal"><span class="std std-ref">Truncated normal distribution</span></a> of the Appendix for a description of the truncated normal distribution.</p>
</aside>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./struct_est"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer">
                  <!-- Previous / next buttons -->
<div class="prev-next-area">
    <a class="left-prev"
       href="GMM.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">Generalized Method of Moments Estimation</p>
      </div>
    </a>
    <a class="right-next"
       href="../appendix/glossary.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Glossary</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">

  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#the-smm-estimator">The SMM estimator</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#the-weighting-matrix-w">The Weighting Matrix (W)</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#the-identity-matrix-w-i">The identity matrix (W=I)</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#two-step-variance-covariance-estimator-of-w">Two-step variance-covariance estimator of W</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#iterated-variance-covariance-estimator-of-w">Iterated variance-covariance estimator of W</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#newey-west-consistent-estimator-of-omega-and-w">Newey-West consistent estimator of <span class="math notranslate nohighlight">\(\Omega\)</span> and W</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#variance-covariance-estimator-of-hat-theta">Variance-Covariance Estimator of <span class="math notranslate nohighlight">\(\hat{\theta}\)</span></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#code-examples">Code Examples</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#fitting-a-truncated-normal-to-intermediate-macroeconomics-test-scores">Fitting a truncated normal to intermediate macroeconomics test scores</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#two-moments-identity-weighting-matrix">Two moments, identity weighting matrix</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#two-moments-two-step-optimal-weighting-matrix">Two moments, two-step optimal weighting matrix</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#four-moments-identity-matrix-weighting-matrix">Four moments, identity matrix weighting matrix</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#four-moments-two-step-optimal-weighting-matrix">Four moments, two-step optimal weighting matrix</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#brock-and-mirman-1972-estimation-by-smm">Brock and Mirman (1972) estimation by SMM</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#secsmm-ident">Identification</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#indirect-inference">Indirect inference</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#restatement-of-the-general-smm-estimation-problem">Restatement of the general SMM estimation problem</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#indirect-inference-estimation-problem">Indirect inference estimation problem</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#hypothesis-testing-with-indirect-inference">Hypothesis testing with indirect inference</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#exercises">Exercises</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#footnotes">Footnotes</a></li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Richard W. Evans
</p>

  </div>
  
  <div class="footer-item">
    
  <p class="copyright">
    
      © Copyright 2023.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/bootstrap.js?digest=c5ced968eda925caa686"></script>
<script src="../_static/scripts/pydata-sphinx-theme.js?digest=c5ced968eda925caa686"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>